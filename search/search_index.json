{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"<code>dmeth</code>: Differential Methylation Analysis Toolkit","text":"<p>A fast, statistically rigorous Python framework providing a toolkit for DNA methylation analysis - from raw beta matrices to biomarkers and functional interpretation. <code>dmeth</code> implements the full modern differential methylation pipeline used in high-impact epigenome-wide association studies (EWAS), with performance and correctness on par with established R/bioconductor tools, all in pure Python.</p>"},{"location":"#key-features","title":"Key Features","text":"Feature Implementation Performance Empirical Bayes moderated t-tests limma-style (Smyth 2004) with exact replication Numba-accelerated (10\u2013100\u00d7 faster) Memory-efficient chunked analysis Automatic fallback for &gt;1M probes &lt;4 GB RAM typical Cell-type deconvolution Reference-based NNLS (Houseman/Horvath-style) Parallel joblib DMR discovery Sliding-window clustering + gap merging Vectorized Gene annotation &amp; pathway enrichment IntervalTree + Fisher\u2019s exact (FDR) Sub-second on 450k/EPIC Coordinate liftover (hg19 \u2194 hg38) pyliftover integration Per-region tracking Biomarker panel discovery &amp; validation RF / Elastic Net + stratified CV Built-in Robust preprocessing &amp; QC Missingness, group representation, imputation Production-safe <p>Fully supports Illumina 450K, EPIC (850K), and any custom CpG \u00d7 sample matrix.</p>"},{"location":"#citation","title":"Citation","text":"<p>If you use <code>dmeth</code> in your research, please cite:</p> <pre><code>@software{dmeth2025,\n  author = {Afolabi, Dare},\n  title = {dmeth: A comprehensive Python toolkit for differential DNA methylation analysis with empirical Bayes moderation and biomarker discovery},\n  version = {0.1.1},\n  year = {2025},\n  publisher = {GitHub},\n  url = {https://github.com/dare-afolabi/dmeth},\n  doi = {10.5281/zenodo.17684037},\n}\n</code></pre>"},{"location":"#references","title":"References","text":"<ul> <li>Smyth, G. K. (2004). Linear models and empirical bayes methods for assessing differential expression in microarray experiments. Statistical Applications in Genetics and Molecular Biology, 3(1).</li> <li>Liu, P., &amp; Hwang, J.T.G. (2007). Quick calculation for sample size while controlling false discovery rate with application to microarray analysis. Bioinformatics, 23(6), 739\u2013746.</li> <li>Du, P., Zhang, X., Huang, C.-C., Jafari, N., Kibbe, W.A., Hou, L., &amp; Lin, S. (2010). Comparison of Beta-value and M-value methods for quantifying methylation levels by microarray analysis. BMC Bioinformatics, 11:587.</li> <li>Jung, S.H., Young, S.S. (2012). Power and sample size calculation for microarray studies. Journal of Biopharmaceutical Statistics, 22(1):30-42.</li> <li>Phipson, B. et al. (2016). missMethyl: an R package for analyzing data from Illumina\u2019s HumanMethylation450 platform. Bioinformatics, 32(2), 286-288.</li> </ul>"},{"location":"#support","title":"Support","text":"<ul> <li>Issues: GitHub Issues</li> <li>Discussions: GitHub Discussions</li> <li>Email: dare.afolabi@outlook.com</li> </ul>"},{"location":"UserGuide/","title":"dmeth - documentation for reproducible DNA methylation analysis","text":""},{"location":"UserGuide/#user-guide","title":"User Guide","text":"<p>A fast, statistically rigorous Python framework providing a toolkit for DNA methylation analysis - from raw beta matrices to biomarkers and functional interpretation. <code>dmeth</code> implements the full modern differential methylation pipeline used in high-impact epigenome-wide association studies (EWAS), with performance and correctness on par with established R/bioconductor tools, all in pure Python.</p>"},{"location":"UserGuide/#key-features","title":"Key Features","text":"Feature Implementation Performance Empirical Bayes moderated t-tests limma-style (Smyth 2004) with exact replication Numba-accelerated (10\u2013100\u00d7 faster) Memory-efficient chunked analysis Automatic fallback for &gt;1M probes &lt;4 GB RAM typical Cell-type deconvolution Reference-based NNLS (Houseman/Horvath-style) Parallel joblib DMR discovery Sliding-window clustering + gap merging Vectorized Gene annotation &amp; pathway enrichment IntervalTree + Fisher\u2019s exact (FDR) Sub-second on 450k/EPIC Coordinate liftover (hg19 \u2194 hg38) pyliftover integration Per-region tracking Biomarker panel discovery &amp; validation RF / Elastic Net + stratified CV Built-in Robust preprocessing &amp; QC Missingness, group representation, imputation Production-safe <p>Fully supports Illumina 450K, EPIC (850K), and any custom CpG \u00d7 sample matrix.</p>"},{"location":"UserGuide/#quick-start","title":"Quick Start","text":"<pre><code>pip install \"dmeth[full]\"\n</code></pre> <pre><code>import pandas as pd\n\nfrom dmeth.io.readers import load_methylation_data\nfrom dmeth.core.analysis.preparation import filter_cpgs_by_missingness, impute_missing_values\nfrom dmeth.core.analysis.validation import validate_design, validate_contrast\nfrom dmeth.core.analysis.core_analysis import fit_differential\nfrom dmeth.core.downstream.annotation import find_dmrs_by_sliding_window\n\n# 1. Load your data\n# beta: CpG x samples matrix\n# pheno: sample metadata with a 'group' column\nbeta = pd.read_csv(\"beta_matrix.csv\", index_col=0)\npheno = pd.read_csv(\"phenotype.csv\", index_col=0)\n\n# 2. Preprocessing\n# Drop CpGs with too much missingness\nbeta_clean, _, _ = filter_cpgs_by_missingness(beta, max_missing_rate=0.2)\n\n# Impute remaining missing values (kNN)\nbeta_imp = impute_missing_values(beta_clean, method=\"knn\", k=10)\n\n# 3. Differential analysis (case vs control)\n# Build design matrix from phenotype\ndesign = validate_design(pheno[\"group\"])\ncontrast = validate_contrast(design, \"case-control\")\n\n# Fit\nres = fit_differential(\n    M=beta_imp,\n    design=pd.DataFrame(design, index=beta_imp.columns),\n    contrast=contrast,\n    shrink=\"smyth\",\n    robust=True,\n)\n\n# 4. Discover DMRs\nannotation = pd.read_csv(\"cpg_annotation.csv\", index_col=0)  # must include chr, pos columns\ndmrs = find_dmrs_by_sliding_window(\n    dms=res[res[\"padj\"] &lt; 0.05],\n    annotation=annotation,\n    max_gap=500,\n    min_cpgs=3,\n)\n\nprint(f\"Found {len(dmrs)} DMRs\")\nprint(dmrs.head())\n</code></pre>"},{"location":"UserGuide/#installation","title":"Installation","text":"<pre><code># Minimal (no speed, annotation, and other extras)\npip install dmeth\n\n# Recommended: full scientific environment\npip install \"dmeth[full]\"\n\n# Development\npip install \"dmeth[full,dev]\"\n</code></pre> <p>Optional extras (dmeth[full]):</p> <ul> <li>speed: numba, combat (highly recommended)</li> <li>annotation: intervaltree, pyliftover</li> <li>parallel: joblib</li> <li>format: PyYAML, toml, h5py, xlrd</li> <li>plotting: plotly, umap-learn</li> <li>io: pyarrow, tables, openpyxl, xlsxwriter</li> </ul> <p>Optional dev extras (dmeth[dev]):</p> <p>pytest, pytest-cov, black, isort, flake8, flake8-pyproject, flake8-bugbear, bandit, mypy, mkdocs, mkdocs-material</p>"},{"location":"UserGuide/#reference-for-all-modules-classes-and-functions","title":"Reference for all modules, classes, and functions","text":""},{"location":"UserGuide/#preprocessing-utilities","title":"Preprocessing Utilities","text":"<p>Core preprocessing utilities for DNA methylation array data.</p> <ul> <li>This module implements quality control, normalization, batch correction, and filtering operations for methylation matrices (beta or M-values).</li> <li>It provides both standard and high-performance implementations with memory-efficient processing for large datasets.</li> </ul>"},{"location":"UserGuide/#features","title":"Features","text":"<ul> <li>Sample-level QC: Flag/remove samples with excessive missing data</li> <li>CpG-level QC: Remove probes with high missingness or on sex chromosomes</li> <li>Normalization: Beta quantile normalization with optional M-value conversion</li> <li>Batch correction: Regression-based or ComBat-style correction</li> <li>Filtering: Remove low-variance probes</li> </ul> <p><code>ProcessedData(M: DataFrame, pheno: DataFrame, ann: DataFrame, meta: Dict[str, Any] = &lt;factory&gt;) -&gt; None</code></p> <p>Central container for aligned methylation data used throughout the DMeth pipeline.</p> <p>Guarantees that:</p> <ul> <li>All components (methylation matrix, sample metadata, probe annotation)     share consistent string indices.</li> <li>Sample and probe alignment is validated on construction.</li> <li>A <code>meta</code> dictionary tracks processing history (normalisation,     batch correction, QC metrics, etc.).</li> </ul> <p>All downstream functions expect or return instances of this class.</p>"},{"location":"UserGuide/#parameters","title":"Parameters","text":"<ul> <li>M: <code>pd.DataFrame</code>     Methylation matrix with CpG sites as rows and samples as columns.     Values are typically beta (0\u20131) or M-values (-inf to +inf).</li> <li>pheno: <code>pd.DataFrame</code>     Sample metadata table. Must be indexed by sample IDs (strings         after construction).</li> <li>ann: <code>pd.DataFrame or None</code>     Optional probe/CpG annotation table (e.g., Illumina manifest).         Must be indexed by CpG IDs.     If <code>None</code>, probe-level alignment checks are skipped.</li> <li>meta: <code>dict, optional</code>     Free-form dictionary storing pipeline provenance and parameters.     Pre-populated with sensible defaults if not provided.</li> </ul>"},{"location":"UserGuide/#attributes","title":"Attributes","text":"<ul> <li>M: <code>pd.DataFrame</code>     Methylation matrix (string-indexed rows and columns).</li> <li>pheno: <code>pd.DataFrame</code>     Sample metadata (string-indexed).</li> <li>ann: <code>pd.DataFrame or None</code>     Probe annotation (string-indexed if present).</li> <li>meta: <code>dict</code>     Processing metadata (e.g., <code>{\"matrix_type\": \"beta\",         \"normalized\": True, ...}</code>).</li> </ul>"},{"location":"UserGuide/#notes","title":"Notes","text":"<p>The <code>__post_init__</code> method automatically:</p> <ul> <li>Converts all relevant indices to strings.</li> <li>Validates alignment between components.</li> <li>Raises informative <code>KeyError</code> on mismatch.</li> </ul> <p><code>batch_correction(data: ProcessedData, batch_col: str, covariates: Optional[List[str]] = None, method: str = 'qr', weights: Optional[ndarray] = None, block_size: int = 50000, robust: bool = False, return_diagnostics: bool = False) -&gt; Union[ProcessedData, Tuple[ProcessedData, Dict[str, Any]]]</code></p> <p>Regression-based batch correction using full linear model (intercept +     covariates + batch).</p> <p>Numerically stable QR/pinv solver with optional per-probe weights and     block-wise processing.</p>"},{"location":"UserGuide/#parameters_1","title":"Parameters","text":"<ul> <li>batch_col: <code>str</code>     Column in <code>pheno</code> identifying batch.</li> <li>covariates: <code>list[str] or None</code>     Additional technical or biological covariates to preserve.</li> <li>method: <code>{\"qr\", \"pinv\"}, default \"qr\"</code>     Solver backend.</li> <li>weights: <code>ndarray or None</code>     Per-probe inverse-variance weights.</li> <li>robust: <code>bool, default False</code>     Use Huber robust regression (much slower).</li> <li>return_diagnostics: <code>bool, default False</code>     Return detailed effect sizes, residuals, and variance explained.</li> </ul>"},{"location":"UserGuide/#returns","title":"Returns","text":"<p>ProcessedData or (ProcessedData, dict)     Corrected data and optional diagnostics.</p> <p><code>batch_correction_combat(data: ProcessedData, batch_col: str, covariates: Optional[List[str]] = None, parametric: bool = True, return_diagnostics: bool = False) -&gt; Union[ProcessedData, Tuple[ProcessedData, Dict[str, Any]]]</code></p> <p>Wrapper for ComBat (or safe fallback) batch correction.</p> <ul> <li>Uses <code>pycombat</code> if installed (parametric or nonparametric).</li> <li>Falls back to conservative mean-centering + variance rescaling with clear warning.</li> <li>Automatically handles beta \u2194 M-value conversion.</li> </ul>"},{"location":"UserGuide/#parameters_2","title":"Parameters","text":"<ul> <li>parametric: <code>bool, default True</code>     Use parametric ComBat (faster, assumes normality).</li> <li>return_diagnostics: <code>bool, default False</code>     Return metadata about which method was actually used.</li> </ul>"},{"location":"UserGuide/#returns_1","title":"Returns","text":"<p>ProcessedData or (ProcessedData, dict)     Batch-corrected data and diagnostics.</p> <p><code>filter_low_variance_cpgs(data: ProcessedData, min_percentile: float = 10.0, inplace: bool = True) -&gt; ProcessedData</code></p> <p>Remove CpGs below a variance percentile threshold (e.g., bottom 10%).</p>"},{"location":"UserGuide/#parameters_3","title":"Parameters","text":"<ul> <li>data : ProcessedData</li> <li>min_percentile : float, default 10.0     Keep only probes with variance \u2265 this percentile.</li> <li>inplace : bool, default True     Modify input object or return a copy.</li> </ul>"},{"location":"UserGuide/#returns_2","title":"Returns","text":"<ul> <li>ProcessedData     Dataset with low-variance probes removed.</li> </ul>"},{"location":"UserGuide/#notes_1","title":"Notes","text":"<ul> <li>Number of removed probes recorded in <code>data.meta[\"qc\"][\"low_variance_removed\"]</code>.</li> </ul> <p><code>normalize_methylation(data: ProcessedData, method: str = 'beta_quantile', convert_to: Optional[str] = None, copy: bool = False, q_chunk_threshold: int = 100000000.0, q_block_probes: int = 50000) -&gt; ProcessedData</code></p> <p>Perform quantile normalization across samples with optional beta \u2194     M-value conversion.</p> <ul> <li>Implements memory-efficient beta quantile normalization using column-wise     sorting and block-wise rank mapping.</li> <li>Automatically falls back to disk-backed memmap for very large datasets.</li> </ul>"},{"location":"UserGuide/#parameters_4","title":"Parameters","text":"<ul> <li>data: <code>ProcessedData</code>     Input methylation data.</li> <li>method: <code>{\"beta_quantile\", \"none\"}, default \"beta_quantile\"</code>     Normalization method.</li> <li>convert_to: <code>{\"beta\", \"m\"} or None, optional</code>     Convert matrix type after normalization (e.g., \"m\" for M-values).</li> <li>copy: <code>bool, default False</code>     Work on a deep copy of the input.</li> <li>q_chunk_threshold: <code>int, default 1e8</code>     Element count threshold (n_probes \u00d7 n_samples) above which memmap is used.</li> <li>q_block_probes: <code>int, default 50_000</code>     Number of probes processed per block during rank-to-target assignment.</li> </ul>"},{"location":"UserGuide/#returns_3","title":"Returns","text":"<p>ProcessedData     Normalized dataset with updated <code>meta[\"normalized\"]</code> and detailed provenance.</p>"},{"location":"UserGuide/#notes_2","title":"Notes","text":"<p>Preserves original NaNs. Records full normalization metadata including     memory strategy.</p> <p><code>normalize_methylation_highperf(data: ProcessedData, method: str = 'beta_quantile', convert_to: Optional[str] = None, copy: bool = False, memmap_threshold: int = 200000000.0, memmap_dir: Optional[str] = None, n_workers: Optional[int] = None, sample_block: int = 16, random_state: Optional[int] = None) -&gt; ProcessedData</code></p> <p>High-performance quantile normalization with multiprocessing and automatic     memmap handling.</p> <p>Designed for &gt;850k \u00d7 500+ datasets. Uses disk-backed arrays when needed     and parallelizes the rank-mapping stage.</p>"},{"location":"UserGuide/#parameters_5","title":"Parameters","text":"<ul> <li>memmap_threshold: <code>int, default 2e8</code>     Element count above which temporary memmap files are created.</li> <li>memmap_dir: <code>str or None</code>     Directory for memmap files (defaults to system temp).</li> <li>n_workers: <code>int or None</code>     Number of processes for parallel assignment (defaults to CPU count \u2013 1).</li> <li>sample_block: <code>int, default 16</code>     Number of samples per parallel job.</li> <li>random_state: <code>int or None</code>     Currently unused (kept for API consistency).</li> </ul>"},{"location":"UserGuide/#returns_4","title":"Returns","text":"<p>ProcessedData     Quantile-normalized data with comprehensive metadata.</p>"},{"location":"UserGuide/#notes_3","title":"Notes","text":"<p>Significantly faster and lower peak RAM than <code>normalize_methylation</code>     on large cohorts.</p> <p><code>qc_cpg_level(data: ProcessedData, max_missing_fraction: float = 0.1, drop_sex_chr: bool = True, chr_col: str = 'chromosome') -&gt; ProcessedData</code></p> <p>Remove CpGs with high missingness across samples and optionally drop     sex-chromosome probes.</p>"},{"location":"UserGuide/#parameters_6","title":"Parameters","text":"<ul> <li>data: <code>ProcessedData</code>     Input dataset.</li> <li>max_missing_fraction: <code>float, default 0.10</code>     Maximum fraction of samples allowed to be missing for a CpG (10% default).</li> <li>drop_sex_chr: <code>bool, default True</code>     If True and annotation is available, remove all probes on chromosomes X and Y.</li> <li>chr_col: <code>str, default \"chromosome\"</code>     Column name in <code>data.ann</code> containing chromosome information.</li> </ul>"},{"location":"UserGuide/#returns_5","title":"Returns","text":"<p>ProcessedData     Updated container with low-quality and/or sex-chromosome CpGs removed.</p>"},{"location":"UserGuide/#notes_4","title":"Notes","text":"<p>Summary statistics are recorded in <code>data.meta[\"qc\"][\"cpg_missing\"]</code>.</p> <p><code>qc_sample_level(data: ProcessedData, max_missing_fraction: float = 0.05, min_nonmissing_probes: Optional[int] = None, remove_samples: bool = True) -&gt; ProcessedData</code></p> <p>Identify and optionally remove samples with excessive missing methylation data.</p>"},{"location":"UserGuide/#parameters_7","title":"Parameters","text":"<ul> <li>data: <code>ProcessedData</code>     Input methylation dataset.</li> <li>max_missing_fraction: <code>float, default 0.05</code>     Maximum allowed fraction of missing CpGs per sample (5% by default).</li> <li>min_nonmissing_probes: <code>int or None, optional</code>     Alternative absolute threshold: minimum number of detected (non-missing)         probes required.</li> <li>remove_samples: <code>bool, default True</code>     If True, flagged samples are removed from both <code>M</code> and <code>pheno</code>;         if False, only metadata is recorded.</li> </ul>"},{"location":"UserGuide/#returns_6","title":"Returns","text":"<p>ProcessedData     Updated container (samples removed if requested).</p>"},{"location":"UserGuide/#notes_5","title":"Notes","text":"<p>Flagged sample list and thresholds are stored in <code>data.meta[\"qc\"]    [\"sample_missing\"]</code>.</p>"},{"location":"UserGuide/#study-planning","title":"Study Planning","text":"<p>High-level planning API for DNA methylation studies.</p> <p>This module provides a clean, user-friendly interface to the full study planning capabilities of <code>DMeth</code>. It exposes all configuration queries, cost/timeline estimators, and sample size calculators as simple top-level functions.</p> <ul> <li>All functions automatically use the global <code>PlannerConfig</code> singleton</li> <li>(managed in <code>dmeth.config.config_manager</code>), so configuration loaded once is immediately available everywhere.</li> </ul>"},{"location":"UserGuide/#features_1","title":"Features","text":"<ul> <li>Direct function access: <code>list_platforms()</code>, <code>calculate_sample_size()</code>, etc.</li> <li>Zero-boilerplate: no need to manually instantiate or pass config objects</li> <li>Real-time updates: any config change (e.g., regional pricing) instantly affects all calculations</li> </ul> <p><code>add_custom_platform(platform_id: str, platform_info: Dict[str, Any]) -&gt; None</code></p> <p>Register a new custom platform after schema validation.</p>"},{"location":"UserGuide/#parameters_8","title":"Parameters","text":"<ul> <li>platform_id: <code>str</code>     Unique identifier for the new platform.</li> <li>platform_info: <code>dict</code>     Platform data conforming to <code>PlatformSchema</code>.</li> </ul>"},{"location":"UserGuide/#raises","title":"Raises","text":"<p>ValueError     If the provided data fails validation.</p> <p><code>calculate_sample_size(*args, **kwargs)</code></p> <p>Compute required sample size per group using power analysis.</p> <ul> <li>The calculation accounts for the chosen experimental design, platform</li> <li>CpG count (for Bonferroni correction), and any design-specific power adjustment factor.</li> </ul>"},{"location":"UserGuide/#parameters_9","title":"Parameters","text":"<ul> <li>design_id: <code>str</code>     Identifier of the experimental design.</li> <li>platform_id: <code>str</code>     Identifier of the methylation platform.</li> <li>effect_size: <code>float</code>     Expected Cohen's d.</li> <li>alpha: <code>float, default 0.05</code>     Nominal type-I error rate.</li> <li>power: <code>float, default 0.8</code>     Desired statistical power.</li> <li>mcp_method: <code>str, optional</code>     Multiple-comparison correction method (<code>bonferroni</code>, <code>fdr</code>, <code>none</code>).</li> <li>max_n: <code>int, default 500</code>     Upper bound on calculated sample size per group.</li> </ul>"},{"location":"UserGuide/#returns_7","title":"Returns","text":"<p>dict     Contains <code>n_per_group</code>, <code>total_samples</code>, effective alpha, etc.</p> <p><code>estimate_study_timeline(*args, **kwargs)</code></p> <p>Produce a detailed timeline estimate for the entire study.</p> <p>The estimate respects phase-specific scaling, batch adjustments, parallelisability, and an optional global contingency buffer.</p>"},{"location":"UserGuide/#parameters_10","title":"Parameters","text":"<ul> <li>n_samples: <code>int</code>     Total number of samples to be processed.</li> <li>platform_id: <code>str</code>     Platform identifier (affects array-processing duration).</li> <li>contingency: <code>bool, default True</code>     Apply the global contingency buffer percentage.</li> </ul>"},{"location":"UserGuide/#returns_8","title":"Returns","text":"<p>DataFrame     One row per phase plus a summary <code>TOTAL</code> row.</p> <p><code>estimate_total_cost(*args, **kwargs)</code></p> <p>Calculate the complete study cost and provide a detailed breakdown.</p> <p>Handles per-sample, per-CpG, and fixed cost components, with optional inclusion of components marked as <code>optional</code>.</p>"},{"location":"UserGuide/#parameters_11","title":"Parameters","text":"<ul> <li>n_samples: <code>int</code>     Number of samples.</li> <li>platform_id: <code>str</code>     Platform identifier.</li> <li>include_optional: <code>bool, default True</code>     Include optional cost components.</li> <li>validate: <code>bool, default True</code>     Perform unit validation (kept for backward compatibility).</li> </ul>"},{"location":"UserGuide/#returns_9","title":"Returns","text":"<p>dict     Contains a <code>components</code> DataFrame, <code>total</code> cost,     <code>per_sample</code> cost, and metadata.</p> <p><code>get_config() -&gt; dmeth.config.config_manager.PlannerConfig</code></p> <p>Retrieve the global singleton instance of <code>PlannerConfig</code>.</p> <p>The instance is created on first access if necessary.</p>"},{"location":"UserGuide/#returns_10","title":"Returns","text":"<p>PlannerConfig     The active configuration object.</p> <p><code>get_cost_components(platform: Optional[str] = None, include_optional: bool = True) -&gt; Dict[str, Dict]</code></p> <p>Return cost components, optionally filtered by platform or optionality.</p>"},{"location":"UserGuide/#parameters_12","title":"Parameters","text":"<ul> <li>platform: <code>str, optional</code>     Restrict to components whose <code>applies_to</code> list contains this platform.</li> <li>include_optional: <code>bool, default True</code>     Whether to include components marked as optional.</li> </ul>"},{"location":"UserGuide/#returns_11","title":"Returns","text":"<p>dict     Mapping from component identifier to component dictionary.</p> <p><code>get_design(design_id: str) -&gt; Dict[str, Any]</code></p> <p>Retrieve the configuration dictionary for a specific experimental design.</p>"},{"location":"UserGuide/#parameters_13","title":"Parameters","text":"<ul> <li>design_id: <code>str</code>     Identifier of the design.</li> </ul>"},{"location":"UserGuide/#returns_12","title":"Returns","text":"<p>dict     Design configuration.</p>"},{"location":"UserGuide/#raises_1","title":"Raises","text":"<p>KeyError     If the design identifier is unknown.</p> <p><code>get_platform(platform_id: str) -&gt; Dict[str, Any]</code></p> <p>Retrieve the configuration dictionary for a specific platform.</p>"},{"location":"UserGuide/#parameters_14","title":"Parameters","text":"<ul> <li>platform_id: <code>str</code>     Identifier of the platform.</li> </ul>"},{"location":"UserGuide/#returns_13","title":"Returns","text":"<p>dict     Platform configuration.</p>"},{"location":"UserGuide/#raises_2","title":"Raises","text":"<p>KeyError     If the platform identifier is unknown.</p> <p><code>get_platform_by_budget(max_cost_per_sample: float) -&gt; DataFrame</code></p> <p>Return platforms whose per-sample cost does not exceed a budget limit.</p>"},{"location":"UserGuide/#parameters_15","title":"Parameters","text":"<ul> <li>max_cost_per_sample: <code>float</code>     Maximum acceptable cost per sample.</li> </ul>"},{"location":"UserGuide/#returns_14","title":"Returns","text":"<p>DataFrame     Subset of platforms meeting the budget constraint.</p> <p><code>list_designs() -&gt; DataFrame</code></p> <p>Return a table of all configured experimental designs.</p>"},{"location":"UserGuide/#returns_15","title":"Returns","text":"<p>DataFrame     One row per design.</p> <p><code>list_platforms(recommended_only: bool = False) -&gt; DataFrame</code></p> <p>Return a DataFrame containing all configured platforms.</p>"},{"location":"UserGuide/#parameters_16","title":"Parameters","text":"<ul> <li>recommended_only: <code>bool, default False</code>     If True, only platforms with <code>recommended=True</code> are returned.</li> </ul>"},{"location":"UserGuide/#returns_16","title":"Returns","text":"<p>DataFrame     One row per platform, indexed by platform identifier.</p> <p><code>update_platform_cost(platform_id: str, new_cost: float) -&gt; None</code></p> <p>Change the per-sample cost of an existing platform.</p>"},{"location":"UserGuide/#parameters_17","title":"Parameters","text":"<ul> <li>platform_id: <code>str</code>     Platform identifier.</li> <li>new_cost: <code>float</code>     New cost per sample (must be non-negative).</li> </ul>"},{"location":"UserGuide/#raises_3","title":"Raises","text":"<p>KeyError     If the platform does not exist.</p> <p><code>update_regional_pricing(multiplier: float, region: Optional[str] = None) -&gt; None</code></p> <p>Apply a uniform multiplicative adjustment to all platform costs.</p>"},{"location":"UserGuide/#parameters_18","title":"Parameters","text":"<ul> <li>multiplier: <code>float</code>     Factor by which current costs are multiplied (must be &gt; 0).</li> <li>region: <code>str, optional</code>     Descriptive label for logging purposes.</li> </ul>"},{"location":"UserGuide/#raises_4","title":"Raises","text":"<p>ValueError     If <code>multiplier</code> is not positive.</p>"},{"location":"UserGuide/#core-differential-analysis","title":"Core Differential Analysis","text":""},{"location":"UserGuide/#core-analysis","title":"Core Analysis","text":"<p>Statistical engines for differential methylation analysis.</p> <p>This module implements empirical Bayes moderated statistics following Smyth (2004) limma methodology, with extensions for paired designs, robust estimation, and Numba-accelerated computation. It provides both full-matrix and chunked processing for memory-constrained environments.</p>"},{"location":"UserGuide/#features_2","title":"Features","text":"<ul> <li>Empirical Bayes variance shrinkage (Smyth method)</li> <li>Robust variance estimation via winsorization</li> <li>Numba JIT compilation for 10-100 x speedup</li> <li>Memory-efficient chunked processing</li> <li>Paired and multi-group designs</li> <li>F-tests for multi-coefficient contrasts</li> <li>Automatic handling of missing data</li> <li>Group mean computation for interpretability</li> </ul> <p><code>SmythPrior(df_prior: 'float', var_prior: 'float') -&gt; None</code></p> <p>SmythPrior(df_prior: 'float', var_prior: 'float')</p> <p><code>check_analysis_memory(M: 'pd.DataFrame', warn_threshold_gb: 'float' = 8.0)</code></p> <p>Conservatively estimate RAM requirements for a full-matrix differential analysis.</p> <ul> <li>Calculates current data footprint, projects peak usage (approximately 4 times     input size), and compares against available system memory.</li> <li>Raises MemoryError early if danger is high, forcing use of chunked mode.</li> </ul>"},{"location":"UserGuide/#parameters_19","title":"Parameters","text":"<ul> <li>M: <code>pd.DataFrame</code>     Methylation matrix (CpGs \u00d7 samples).</li> <li>warn_threshold_gb: <code>float, default 8.0</code>     Issue a warning if estimated peak exceeds this value.</li> </ul>"},{"location":"UserGuide/#returns_17","title":"Returns","text":"<p>dict     Keys: <code>data_gb</code>, <code>peak_gb</code>, <code>available_gb</code>.</p>"},{"location":"UserGuide/#raises_5","title":"Raises","text":"<p>MemoryError     If projected peak consumption exceeds ~80% of available RAM. In such cases         <code>fit_differential_chunked</code> should be used instead.</p> <p><code>fit_differential(M: 'pd.DataFrame', design: 'pd.DataFrame', contrast: 'Optional[np.ndarray]' = None, contrast_matrix: 'Optional[np.ndarray]' = None, shrink: 'Union[str, float]' = 'auto', robust: 'bool' = True, eps: 'float' = 1e-08, return_residuals: 'bool' = False, min_count: 'int' = 3, max_d0: 'float' = 50.0, winsor_lower: 'float' = 0.05, winsor_upper: 'float' = 0.95, group_labels: 'Optional[pd.Series]' = None, use_numba: 'bool' = True) -&gt; 'Union[pd.DataFrame, Tuple[pd.DataFrame, pd.DataFrame]]'</code></p> <p>Core limma-style differential methylation analysis with empirical Bayes moderation.</p> <ul> <li>Features: <code>- Numba-accelerated feature-wise fitting (10\u2013100\u00d7 speedup when no missing data)</code></li> <li>Automatic handling of missing values</li> <li>Robust winsorization of residuals</li> <li>Multiple shrinkage strategies (Smyth, median, fixed d\u2080, none)</li> <li>Single-contrast t-tests or multi-coefficient F-tests</li> <li>Optional group mean beta/M-value columns for interpretability</li> <li>Optional residuals return for diagnostics</li> </ul>"},{"location":"UserGuide/#parameters_20","title":"Parameters","text":"<ul> <li>M: <code>pd.DataFrame</code>     CpG \u00d7 sample matrix of M-values (or beta values if already on log-odds scale).</li> <li>design: <code>pd.DataFrame</code>     Sample \u00d7 covariate design matrix (output from <code>patsy</code> or manual construction). contrast / contrast_matrix : np.ndarray or None     Contrast vector (t-test) or matrix (F-test).</li> <li>shrink: <code>{\"auto\", \"smyth\", \"median\", \"none\"} or float</code>     Variance shrinkage method or fixed prior df.</li> <li>robust: <code>bool, default True</code>     Winsorize residuals per feature.</li> <li>group_labels: <code>pd.Series, optional</code>     Explicit sample grouping for mean columns; otherwise heuristically detected.</li> <li>use_numba: <code>bool, default True</code>     Enable JIT-compiled loop when possible.</li> </ul>"},{"location":"UserGuide/#returns_18","title":"Returns","text":"<p>pd.DataFrame     Results table with columns including <code>logFC</code>, <code>t</code>, <code>pval</code>, <code>padj</code>         (or <code>F</code>, <code>df1</code>, <code>df2</code>), moderated variances (<code>s2_post</code>), prior df         (<code>d0</code>), and group means. (pd.DataFrame, pd.DataFrame), optional     Second element contains per-feature residuals if <code>return_residuals=True</code>.</p> <p><code>fit_differential_chunked(M: 'pd.DataFrame', design: 'pd.DataFrame', chunk_size: 'int' = 10000, verbose: 'bool' = True, group_labels: 'Optional[pd.Series]' = None, **kwargs) -&gt; 'pd.DataFrame'</code></p> <p>Memory-efficient version of <code>fit_differential</code> that processes features in chunks.</p> <p>Useful for &gt;1M probe arrays on limited RAM. P-values are combined     globally and FDR-corrected once at the end.</p>"},{"location":"UserGuide/#parameters_21","title":"Parameters","text":"<ul> <li>chunk_size: <code>int, default 10000</code>     Number of CpGs per processing chunk. **kwargs     All additional arguments forwarded to <code>fit_differential</code>.</li> </ul>"},{"location":"UserGuide/#returns_19","title":"Returns","text":"<p>pd.DataFrame     Complete results table with globally adjusted p-values and group means.</p>"},{"location":"UserGuide/#postprocessing","title":"Postprocessing","text":"<p>Postprocessing and interpretation utilities for differential methylation analysis results.</p> <p>This module provides robust, publication-ready tools for summarizing, filtering, and extracting biologically meaningful differentially methylated CpGs from statistical output. It supports flexible significance criteria, effect-size thresholding, directional filtering, and delta-beta constraints, with comprehensive summary statistics for reporting.</p>"},{"location":"UserGuide/#features_3","title":"Features","text":"<ul> <li>Comprehensive summary statistics including significance counts, directionality, effect sizes, and empirical Bayes shrinkage metrics</li> <li>Flexible extraction of significant CpGs with adjustable logFC, adjusted p-value, and delta-beta thresholds</li> <li>Directional filtering for hyper- and hypomethylated sites</li> <li>Automatic detection or explicit specification of group mean beta-value columns for delta-beta filtering</li> <li>Graceful handling of missing columns and empty result sets with informative warnings</li> <li>Optional detailed summary dictionaries for downstream reporting or visualization</li> </ul> <p><code>get_significant_cpgs(res: DataFrame, lfc_col: str = 'logFC', pval_col: str = 'padj', lfc_thresh: float = 0.0, pval_thresh: float = 0.05, delta_beta_thresh: Optional[float] = None, direction: Optional[str] = None, delta_beta_cols: Optional[List[str]] = None, return_summary: bool = False, verbose: bool = True) -&gt; Union[List[str], Dict]</code></p> <p>Extract biologically meaningful significant CpGs using flexible,     multi-layer filtering.</p> <ul> <li>Combines adjusted p-value, log fold-change, directionality, and optional     absolute delta-beta criteria.</li> <li>Ideal for generating final candidate lists for downstream validation or     pathway analysis.</li> </ul>"},{"location":"UserGuide/#parameters_22","title":"Parameters","text":"<ul> <li>res: <code>pd.DataFrame</code>     Full differential methylation results table.</li> <li>lfc_col: <code>str, default \"logFC\"</code>     Column containing log\u2082 fold change.</li> <li>pval_col: <code>str, default \"padj\"</code>     Column containing adjusted p-values.</li> <li>lfc_thresh: <code>float, default 0.0</code>     Minimum absolute |logFC| required (0 means no LFC filtering).</li> <li>pval_thresh: <code>float, default 0.05</code>     Maximum adjusted p-value for significance.</li> <li>delta_beta_thresh: <code>float or None, optional</code>     Minimum absolute difference in mean beta values between groups.</li> <li>direction: <code>{\"hyper\", \"hypo\", None}, optional</code>     Restrict to hypermethylated (logFC &gt; 0), hypomethylated (logFC &lt; 0), or both.</li> <li>delta_beta_cols: <code>list[str] or None, optional</code>     Exactly two column names containing group mean beta values (e.g.         <code>[\"meanB_case\", \"meanB_control\"]</code>).     If <code>None</code> and delta-beta filtering is requested, automatically detects         columns starting with <code>meanB_</code>.</li> <li>return_summary: <code>bool, default False</code>     If True, return a detailed dictionary instead of just the CpG list.</li> <li>verbose: <code>bool, default True</code>     Warn when no significant CpGs are found.</li> </ul>"},{"location":"UserGuide/#returns_20","title":"Returns","text":"<p>list[str] or dict     List of significant CpG IDs (default)     Or a summary dictionary containing counts, directional breakdown,         mean |logFC|, and the CpG list</p>"},{"location":"UserGuide/#raises_6","title":"Raises","text":"<p>KeyError     If required columns (<code>lfc_col</code> or <code>pval_col</code>) are missing. ValueError     If <code>delta_beta_thresh</code> is used but exactly two mean-beta columns         cannot be identified.</p> <p><code>summarize_differential_results(res: DataFrame, pval_thresh: float = 0.05, verbose: bool = True) -&gt; Dict[str, Union[int, float]]</code></p> <p>Produce a comprehensive, publication-ready summary of differential     methylation results.</p> <p>Handles missing columns gracefully and returns key metrics for reporting: significance counts, directionality, effect-size statistics, and     variance-shrinkage diagnostics.</p>"},{"location":"UserGuide/#parameters_23","title":"Parameters","text":"<ul> <li>res: <code>pd.DataFrame</code>     Differential methylation results containing at minimum <code>logFC</code> and <code>padj</code>.     May also include <code>pval</code>, <code>s2</code>, <code>s2_post</code>, and <code>d0</code>         (prior degrees of freedom).</li> <li>pval_thresh: <code>float, default 0.05</code>     Adjusted p-value threshold defining statistical significance.</li> <li>verbose: <code>bool, default True</code>     Emit warnings for empty input or missing optional columns.</li> </ul>"},{"location":"UserGuide/#returns_21","title":"Returns","text":"<p>dict     Summary dictionary with the following keys:     <code>total_tested</code>: total CpGs tested     <code>significant</code>: number of significant CpGs (padj &lt; threshold)     <code>pct_significant</code>: percentage of significant CpGs     <code>hypermethylated</code> / <code>hypomethylated</code>: directional counts     <code>mean_abs_logFC_sig</code> / <code>median_abs_logFC_sig</code>:         effect size summaries among significant sites     <code>max_abs_logFC</code>: largest absolute log fold change     <code>min_pval</code>: smallest raw p-value     <code>shrinkage_factor</code>: median ratio of moderated to original variance     <code>d0</code>: median prior degrees of freedom (empirical Bayes)</p>"},{"location":"UserGuide/#notes_6","title":"Notes","text":"<p>Missing optional columns are safely ignored with fallback values. Empty input returns a zero-filled summary.</p>"},{"location":"UserGuide/#preparation","title":"Preparation","text":"<p>Data preparation and preprocessing utilities for differential methylation analysis.</p> <p>This module provides robust, production-ready tools for cleaning and imputing CpG-level methylation matrices prior to statistical modeling. It implements stringent quality-control filters based on missingness patterns and group representation, alongside flexible imputation strategies optimized for high-dimensional epigenomic data.</p>"},{"location":"UserGuide/#features_4","title":"Features","text":"<ul> <li>Global and per-group missingness filtering with configurable thresholds</li> <li>Minimum representation enforcement across experimental groups</li> <li>Multiple imputation methods: row-wise mean/median and K-nearest neighbors</li> <li>Sample-wise KNN option for dramatic speed gains when samples \u226a CpGs</li> <li>Comprehensive input validation and clear diagnostic reporting</li> <li>Memory-efficient operations using NumPy-based vectorization</li> </ul> <p><code>filter_cpgs_by_missingness(M: 'pd.DataFrame', max_missing_rate: 'float' = 0.2, min_samples_per_group: 'Optional[int]' = None, groups: 'Optional[pd.Series]' = None) -&gt; 'Tuple[pd.DataFrame, int, int]'</code></p> <p>Remove CpGs exceeding a global missingness threshold and/or failing     per-group representation.</p>"},{"location":"UserGuide/#parameters_24","title":"Parameters","text":"<ul> <li>M: <code>pd.DataFrame</code>     Methylation matrix (CpGs \u00d7 samples) containing possible NaN values.</li> <li>max_missing_rate: <code>float, default 0.2</code>     Maximum allowable fraction of missing values across all samples (0\u20131).</li> <li>min_samples_per_group: <code>int or None, optional</code>     Minimum number of non-missing observations required in every experimental group.     Ignored if <code>None</code>.</li> <li>groups: <code>pd.Series or None, optional</code>     Sample group labels indexed by <code>M.columns</code>. Required when         <code>min_samples_per_group</code> is set.</li> </ul>"},{"location":"UserGuide/#returns_22","title":"Returns","text":"<ul> <li>filtered: <code>pd.DataFrame</code>     Subset of CpGs passing both filters.</li> <li>n_removed: <code>int</code>     Number of CpGs removed.</li> <li>n_kept: <code>int</code>     Number of CpGs retained.</li> </ul>"},{"location":"UserGuide/#raises_7","title":"Raises","text":"<p>ValueError     If <code>min_samples_per_group</code> is supplied without <code>groups</code> or if group         labels are misaligned.</p> <p><code>filter_min_per_group(M: 'pd.DataFrame', groups: 'pd.Series', min_per_group: 'int' = 5, verbose: 'bool' = True) -&gt; 'pd.DataFrame'</code></p> <p>Retain only CpGs with at least <code>min_per_group</code> non-missing     values in one experimental group.</p> <p>Useful for ensuring sufficient representation before differential analysis.</p>"},{"location":"UserGuide/#parameters_25","title":"Parameters","text":"<ul> <li>M: <code>pd.DataFrame</code>     Methylation matrix (CpGs \u00d7 samples) possibly containing NaN.</li> <li>groups: <code>pd.Series</code>     Group membership for each sample (index must match <code>M.columns</code>).</li> <li>min_per_group: <code>int, default 5</code>     Minimum number of observed (non-missing) values required per group.</li> <li>verbose: <code>bool, default True</code>     Log a concise summary of filtering results.</li> </ul>"},{"location":"UserGuide/#returns_23","title":"Returns","text":"<p>pd.DataFrame     Filtered matrix containing only qualifying CpGs.</p>"},{"location":"UserGuide/#raises_8","title":"Raises","text":"<p>ValueError     If group labels do not cover all samples in <code>M</code>.</p> <p><code>impute_missing_values(M: 'pd.DataFrame', method: 'str' = 'mean', k: 'int' = 5, use_sample_knn: 'bool' = False) -&gt; 'pd.DataFrame'</code></p> <p>Impute missing methylation values using row-wise statistics or K-nearest neighbours.</p>"},{"location":"UserGuide/#parameters_26","title":"Parameters","text":"<ul> <li>M: <code>pd.DataFrame</code>     CpG \u00d7 sample matrix with possible NaN entries.</li> <li>method: <code>{\"mean\", \"median\", \"knn\"}, default \"mean\"</code>     Imputation strategy.</li> <li>k: <code>int, default 5</code>     Number of neighbours used for KNN imputation.</li> <li>use_sample_knn: <code>bool, default False</code>     If True, KNN is performed across samples (samples \u226a CpGs) rather         than across CpGs.     Dramatically faster for typical array datasets.</li> </ul>"},{"location":"UserGuide/#returns_24","title":"Returns","text":"<p>pd.DataFrame     Imputed matrix with the same index/columns as input.</p>"},{"location":"UserGuide/#notes_7","title":"Notes","text":"<ul> <li><code>mean</code> and <code>median</code> are applied row-wise (per CpG).</li> <li><code>knn</code> uses scikit-learn's <code>KNNImputer</code> with distance weighting.</li> <li>No imputation is performed if the matrix contains no missing values.</li> </ul>"},{"location":"UserGuide/#validation","title":"Validation","text":"<p>Input validation and integrity checks for differential methylation analysis.</p> <ul> <li>This module implements rigorous pre-analysis validation of data matrices, experimental designs, contrasts, sample alignment, and system resources. - It ensures statistical estimability, correct pairing structure, and sufficient memory before launching computationally intensive analyses, preventing silent failures and ambiguous results.</li> </ul>"},{"location":"UserGuide/#features_5","title":"Features","text":"<ul> <li>Accurate memory footprint estimation with conservative peak usage prediction and automatic MemoryError on insufficient RAM</li> <li>Strict validation of two-group design vectors with automatic construction of intercept + indicator design matrix</li> <li>Comprehensive contrast validation including shape, zero-vector detection, and QR-based estimability checking</li> <li>Flexible string contrast syntax (\"treatment-control\") for simple two-column designs</li> <li>Thorough alignment verification between methylation data columns, design matrix rows, and optional sample identifiers</li> <li>Robust paired-sample validation ensuring exactly two observations per subject and balanced group representation within pairs</li> <li>Clear, actionable error messages and logging for rapid debugging in production pipelines</li> </ul> <p><code>check_analysis_memory(M: 'pd.DataFrame', warn_threshold_gb: 'float' = 8.0)</code></p> <p>Conservatively estimate RAM requirements for a full-matrix differential analysis.</p> <ul> <li>Calculates current data footprint, projects peak usage (approximately 4 times     input size), and compares against available system memory.</li> <li>Raises MemoryError early if danger is high, forcing use of chunked mode.</li> </ul>"},{"location":"UserGuide/#parameters_27","title":"Parameters","text":"<ul> <li>M: <code>pd.DataFrame</code>     Methylation matrix (CpGs \u00d7 samples).</li> <li>warn_threshold_gb: <code>float, default 8.0</code>     Issue a warning if estimated peak exceeds this value.</li> </ul>"},{"location":"UserGuide/#returns_25","title":"Returns","text":"<p>dict     Keys: <code>data_gb</code>, <code>peak_gb</code>, <code>available_gb</code>.</p>"},{"location":"UserGuide/#raises_9","title":"Raises","text":"<p>MemoryError     If projected peak consumption exceeds ~80% of available RAM. In such cases         <code>fit_differential_chunked</code> should be used instead.</p> <p><code>validate_alignment(data: 'pd.DataFrame', design_matrix: 'np.ndarray', sample_names: 'Optional[Sequence]' = None, paired_ids: 'Optional[Sequence]' = None, group_col_idx: 'int' = 1) -&gt; 'Tuple[pd.Index, np.ndarray, Optional[np.ndarray]]'</code></p> <p>Ensure perfect alignment between methylation data, design matrix, and optional     pairing information.</p> <p>Verifies sample counts, column ordering, duplicate names, and (if supplied)     paired-subject structure.</p>"},{"location":"UserGuide/#parameters_28","title":"Parameters","text":"<ul> <li>data: <code>pd.DataFrame</code>     Methylation matrix with samples in columns.</li> <li>design_matrix: <code>np.ndarray</code>     Corresponding design matrix.</li> <li>sample_names: <code>Sequence or None</code>     Explicit ordered list of sample identifiers (required only         if column names differ).</li> <li>paired_ids: <code>Sequence or None</code>     Subject/block identifiers for paired designs; each ID must appear exactly twice.</li> <li>group_col_idx: <code>int, default 1</code>     Column in design_matrix encoding group membership (used to verify         balanced pairing).</li> </ul>"},{"location":"UserGuide/#returns_26","title":"Returns","text":"<p>tuple     (ordered_data_columns, validated_design_matrix, validated_paired_array_or_None)</p>"},{"location":"UserGuide/#raises_10","title":"Raises","text":"<p>ValueError     On any misalignment, duplicate column names, or invalid pairing structure         (e.g., a subject with both samples in the same group).</p> <p><code>validate_contrast(design_matrix: 'np.ndarray', contrast: 'Union[np.ndarray, Sequence[float], str]') -&gt; 'np.ndarray'</code></p> <p>Validate and normalise a contrast against a given design matrix.</p> <ul> <li>Supports: <code>- Numeric vectors/matrices</code></li> <li>Simple string syntax <code>\"treatment-control\"</code> (only for two-column     intercept + group designs)</li> </ul> <p>Checks dimensionality, non-zero status, and estimability via QR decomposition.</p>"},{"location":"UserGuide/#parameters_29","title":"Parameters","text":"<ul> <li>design_matrix: <code>np.ndarray</code>     Full design matrix (n_samples \u00d7 n_coefficients).</li> <li>contrast: <code>np.ndarray, Sequence[float], or str</code>     Contrast specification.</li> </ul>"},{"location":"UserGuide/#returns_27","title":"Returns","text":"<p>np.ndarray     Validated contrast vector (float64.</p>"},{"location":"UserGuide/#raises_11","title":"Raises","text":"<p>ValueError     On shape mismatch, zero contrast, or non-estimable contrast.</p> <p><code>validate_design(design: 'Sequence') -&gt; 'pd.DataFrame'</code></p> <p>Convert a simple two-group label vector into a proper design matrix.</p> <p>Accepts lists, tuples, arrays, or pandas Series containing exactly two     distinct group labels and returns a two-column matrix:</p> <ul> <li>Column 0: intercept (all 1s)</li> <li>Column 1: group indicator (0 = reference group, 1 = alternative)</li> </ul>"},{"location":"UserGuide/#parameters_30","title":"Parameters","text":"<ul> <li>design: <code>Sequence</code>     Vector of group assignments (length \u2265 2).</li> </ul>"},{"location":"UserGuide/#returns_28","title":"Returns","text":"<p>pd.DataFrame     n_sample \u00d7 2 design matrix acceptable for <code>fit_differential</code>.</p>"},{"location":"UserGuide/#raises_12","title":"Raises","text":"<p>TypeError     If input is not a supported sequence type. ValueError     If fewer than two samples, NaNs present, or more/less than two unique groups.</p>"},{"location":"UserGuide/#downstream-analysis","title":"Downstream Analysis","text":""},{"location":"UserGuide/#annotation","title":"Annotation","text":"<p>Annotation and functional interpretation utilities for DNA methylation analysis.</p> <p>This module delivers a complete suite of tools for translating CpG- and region-level differential methylation results into biological context. It enables rapid gene annotation, pathway- and gene-set enrichment analysis, computation of pathway-level methylation activity, correlation with gene expression, and reliable coordinate liftover across genome assemblies \u2014 all implemented with performance and robustness suitable for genome-wide studies.</p>"},{"location":"UserGuide/#features_6","title":"Features","text":"<ul> <li>Ultra-fast nearest-gene annotation using IntervalTree with graceful fallback to distance-based mapping</li> <li>Fisher\u2019s exact test gene-set enrichment with automatic background correction, size filtering, and FDR adjustment</li> <li>Flexible pathway-level methylation scoring (mean/median/sum) from user-provided gene-to-pathway mappings</li> <li>Sample-aware Pearson/Spearman correlation between CpG methylation and gene expression with robust overlap handling</li> <li>High-accuracy genomic liftover via pyliftover (hg19 \u2194 hg38 and other builds) with per-region success tracking</li> <li>Comprehensive handling of missing dependencies, empty inputs, and chromosome naming conventions</li> <li>Preservation of original indices and seamless integration with DMeth result tables</li> </ul> <p><code>adjust_pvalues(pvals: Union[pandas.core.series.Series, ndarray, List[float]], method: str = 'fdr_bh') -&gt; pandas.core.series.Series</code></p> <p>Apply multiple-testing correction to raw p-values using statsmodels.</p> <p>Handles NaN values robustly (treated as non-significant) and preserves the     original index when input is a pandas Series.</p>"},{"location":"UserGuide/#parameters_31","title":"Parameters","text":"<ul> <li>pvals: <code>array-like</code>     Raw p-values (0 \u2264 p \u2264 1).</li> <li>method: <code>str, default \"fdr_bh\"</code>     Correction method passed to <code>statsmodels.stats.multitest.multipletests</code>.     Supported: <code>\"bonferroni\"</code>, <code>\"holm\"</code>, <code>\"fdr_bh\"</code>, <code>\"fdr_by\"</code>,         <code>\"sidak\"</code>, <code>\"none\"</code>.</li> </ul>"},{"location":"UserGuide/#returns_29","title":"Returns","text":"<p>pd.Series     Adjusted p-values with identical index/order as input.</p> <p><code>annotate_dms_with_genes(dms: 'pd.DataFrame', genes: 'pd.DataFrame', cpg_chr_col: 'str' = 'chr', cpg_pos_col: 'str' = 'pos', gene_chr_col: 'str' = 'chr', gene_start_col: 'str' = 'start', gene_end_col: 'str' = 'end', gene_name_col: 'str' = 'gene_symbol', max_distance: 'int' = 5000) -&gt; 'pd.DataFrame'</code></p> <p>Assign nearest gene(s) to each differentially methylated site     (DMS) using genomic coordinates.</p> <p>Uses IntervalTree for ultra-fast exact overlap queries when available;     automatically falls back to distance-based nearest-gene mapping if the     dependency is missing.</p>"},{"location":"UserGuide/#parameters_32","title":"Parameters","text":"<ul> <li>dms: <code>pd.DataFrame</code>     Table of differentially methylated CpGs with chromosome and position columns.</li> <li>genes: <code>pd.DataFrame</code>     Gene annotation table containing chromosome, start, end, and gene symbol. cpg_chr_col, cpg_pos_col : str     Column names in <code>dms</code> for chromosome and position (default: \"chr\", \"pos\"). gene_chr_col, gene_start_col, gene_end_col, gene_name_col : str     Corresponding column names in <code>genes</code> (default: \"chr\", \"start\",         \"end\", \"gene_symbol\").</li> <li>max_distance: <code>int, default 5000</code>     Maximum distance (bp) considered for nearest-gene assignment when         no overlap exists.</li> </ul>"},{"location":"UserGuide/#returns_30","title":"Returns","text":"<p>pd.DataFrame     Original <code>dms</code> with an added <code>nearest_gene</code> column containing         comma-separated gene symbols (or NaN if none found).</p>"},{"location":"UserGuide/#notes_8","title":"Notes","text":"<ul> <li>Handles mixed chromosome naming conventions via internal normalization.</li> <li>Multiple overlapping genes are reported (e.g., bidirectional promoters).</li> </ul> <p><code>correlate_methylation_expression(beta: 'pd.DataFrame', expression: 'pd.DataFrame', gene_map: 'Optional[Dict[str, str]]' = None, method: 'str' = 'pearson', override_index_alignment: 'bool' = False) -&gt; 'pd.DataFrame'</code></p> <p>Compute sample-wise correlation between CpG methylation and gene expression.</p> <p>Supports both one-to-one (same index) and many-to-one (custom CpG\u2192gene     mapping) scenarios.</p>"},{"location":"UserGuide/#parameters_33","title":"Parameters","text":"<p>beta, expression : pd.DataFrame     Methylation (CpGs \u00d7 samples) and expression (genes \u00d7 samples) matrices. - gene_map: <code>dict or None</code>     Explicit mapping from CpG ID \u2192 gene symbol (required for cis-analysis). - method: <code>{\"pearson\", \"spearman\"}, default \"pearson\"</code>     Correlation coefficient to compute. - override_index_alignment: <code>bool, default False</code>     Proceed even with &lt;2 overlapping samples (useful for exploratory checks).</p>"},{"location":"UserGuide/#returns_31","title":"Returns","text":"<p>pd.DataFrame     Correlation results with columns <code>r</code> and <code>pval</code> (indexed by CpG         and optionally gene).</p> <p><code>gene_set_enrichment(gene_list: 'List[str]', background: 'Optional[List[str]]' = None, gene_sets: 'Optional[Dict[str, List[str]]]' = None, method: 'str' = 'fisher', pval_cutoff: 'float' = 0.05, min_set_size: 'int' = 5, max_set_size: 'int' = 500) -&gt; 'pd.DataFrame'</code></p> <p>Perform over-representation analysis (Fisher\u2019s exact test) on a list     of genes against predefined gene sets (e.g., GO, KEGG, Reactome).</p> <p>Automatically filters gene sets by size and applies FDR correction.</p>"},{"location":"UserGuide/#parameters_34","title":"Parameters","text":"<ul> <li>gene_list: <code>list[str]</code>     Genes of interest (e.g., nearest genes of significant DMS/DMRs).</li> <li>background: <code>list[str] or None</code>     Background gene universe. Defaults to union of all genes in <code>gene_sets</code>.</li> <li>gene_sets: <code>dict[str, list[str]]</code>     Mapping from pathway/term name to member genes. min_set_size, max_set_size : int     Exclude overly small or large gene sets (default 5\u2013500).</li> <li>pval_cutoff: <code>float, default 0.05</code>     Return only terms with adjusted p-value \u2264 this threshold.</li> </ul>"},{"location":"UserGuide/#returns_32","title":"Returns","text":"<p>pd.DataFrame     Enriched terms with columns: <code>term</code>, <code>pvalue</code>, <code>padj</code>,         <code>oddsratio</code>, <code>overlap</code>, <code>set_size</code>.</p> <p><code>liftover_coordinates(regions: 'pd.DataFrame', from_build: 'str' = 'hg19', to_build: 'str' = 'hg38', chr_col: 'str' = 'chr', start_col: 'str' = 'start', end_col: 'str' = 'end') -&gt; 'pd.DataFrame'</code></p> <p>Convert genomic regions between genome assemblies using pyliftover     (e.g., hg19 \u2194 hg38).</p> <p>Handles both single-base and interval coordinates with per-row success reporting.</p>"},{"location":"UserGuide/#parameters_35","title":"Parameters","text":"<ul> <li>regions: <code>pd.DataFrame</code>     Table containing chromosome, start, and end columns. from_build, to_build : str     Source and target genome builds (default: hg19 \u2192 hg38). chr_col, start_col, end_col : str     Column names for genomic coordinates.</li> </ul>"},{"location":"UserGuide/#returns_33","title":"Returns","text":"<p>pd.DataFrame     Original table augmented with:     <code>lifted_chr</code>, <code>lifted_start</code>, <code>lifted_end</code> <code>lifted</code> (boolean indicating successful conversion)</p>"},{"location":"UserGuide/#raises_13","title":"Raises","text":"<p>RuntimeError     If <code>pyliftover</code> is not installed.</p> <p><code>pathway_methylation_scores(beta: 'pd.DataFrame', annotation: 'pd.DataFrame', pathway_db: 'Dict[str, List[str]]', method: 'str' = 'mean') -&gt; 'pd.DataFrame'</code></p> <p>Collapse CpG-level beta values into pathway-level methylation scores per sample.</p> <p>Useful for downstream pathway-activity modeling or visualization.</p>"},{"location":"UserGuide/#parameters_36","title":"Parameters","text":"<ul> <li>beta: <code>pd.DataFrame</code>     Beta-value matrix (CpGs \u00d7 samples).</li> <li>annotation: <code>pd.DataFrame</code>     Mapping from CpG identifiers to gene symbols (index \u2192 gene).</li> <li>pathway_db: <code>dict[str, list[str]]</code>     Dictionary of pathways \u2192 list of associated genes.</li> <li>method: <code>{\"mean\", \"median\", \"sum\"}, default \"mean\"</code>     Aggregation function applied across CpGs belonging to each pathway.</li> </ul>"},{"location":"UserGuide/#returns_34","title":"Returns","text":"<p>pd.DataFrame     Pathways \u00d7 samples matrix of aggregated methylation scores.</p>"},{"location":"UserGuide/#deconvolution","title":"Deconvolution","text":"<p>Cell-type deconvolution utilities for bulk DNA methylation data.</p> <p>This module provides fast, reference-based estimation of cell-type proportions from epigenome-wide methylation profiles using constrained non-negative least squares (NNLS). It supports integration of published reference matrices (e.g., blood, brain, tumor microenvironment) and enables accurate correction for cellular heterogeneity in differential methylation studies.</p>"},{"location":"UserGuide/#features_7","title":"Features","text":"<ul> <li>High-performance NNLS deconvolution with automatic feature alignment between bulk and reference</li> <li>Optional parallel processing via joblib for large cohorts (hundreds to thousands of samples)</li> <li>Robust normalization of estimated proportions to sum-to-1 per sample</li> <li>Graceful handling of missing joblib dependency with automatic fallback to serial execution</li> <li>Clear error reporting when no overlapping CpGs exist between dataset and reference</li> <li>Direct compatibility with standard beta-value matrices (CpGs \u00d7 samples) used throughout DMeth)</li> <li>Extensible design for future reference-free (e.g., EpiDISH HEpiDISH, MeDeCom) or projective methods</li> </ul> <p><code>estimate_cell_composition(beta: DataFrame, ref_profiles: DataFrame, method: str = 'nnls', n_jobs: int = 1) -&gt; DataFrame</code></p> <p>Perform reference-based cell-type deconvolution of bulk DNA methylation     data using constrained non-negative least squares (NNLS).</p> <p>Estimates the relative proportions of predefined cell types in each     sample by solving the linear mixture model:     \u03b2_bulk \u2248 R \u00b7 w</p> <p>where R contains cell-type-specific methylation reference profiles     and w \u2265 0 are the unknown proportions.</p>"},{"location":"UserGuide/#parameters_37","title":"Parameters","text":"<ul> <li>beta: <code>pd.DataFrame</code>     Bulk beta-value matrix with CpGs as rows (index) and samples as columns.     Values must be in [0, 1]; missing values are not supported.</li> <li>ref_profiles: <code>pd.DataFrame</code>     Reference matrix of pure cell-type methylation profiles.     Must have the same CpG index as <code>beta</code> (or a subset thereof) and cell         types as columns.</li> <li>method: <code>str, default \"nnls\"</code>     Deconvolution algorithm. Currently only <code>\"nnls\"</code> (scipy.optimize.nnls)         is implemented.</li> <li>n_jobs: <code>int, default 1</code>     Number of parallel processes for sample-wise deconvolution.     Requires <code>joblib</code>; automatically falls back to serial execution if         unavailable or set to 1.</li> </ul>"},{"location":"UserGuide/#returns_35","title":"Returns","text":"<p>pd.DataFrame     Estimated cell-type proportions with:     rows = samples (same order and names as <code>beta.columns</code>)     columns = cell types (same as <code>ref_profiles.columns</code>)     values constrained to \u22650 and normalized to sum to 1 per sample</p>"},{"location":"UserGuide/#raises_14","title":"Raises","text":"<p>ValueError     If no overlapping CpG features exist between <code>beta</code> and <code>ref_profiles</code>.</p>"},{"location":"UserGuide/#notes_9","title":"Notes","text":"<ul> <li>Automatic feature alignment: only CpGs present in both matrices are used.</li> <li>Proportions are forcibly normalized to sum to 1 (with protection against     division by zero).</li> <li>Highly efficient for typical blood, brain, or tumor microenvironment references     (e.g., FlowSorted.Blood.EPIC, Houseman, etc.).</li> <li>Designed for seamless integration with DMeth preprocessing pipelines     (beta-value input expected).</li> </ul>"},{"location":"UserGuide/#downstream-stats","title":"Downstream Stats","text":"<p>Core statistical utilities for DNA methylation analysis downstream of differential testing.</p> <ul> <li>This module provides a comprehensive suite of high-performance, publication-grade functions for p-value adjustment, effect-size computation, delta-beta calculation, reproducible DMR calling via sliding-window clustering, regional summarization, and cross-dataset reproducibility assessment.</li> <li>Designed for seamless integration into DMeth pipelines, all functions operate efficiently on large epigenome-wide datasets while preserving genomic coordinates and CpG identifiers.</li> </ul>"},{"location":"UserGuide/#features_8","title":"Features","text":"<ul> <li>Multiple p-value correction methods via statsmodels with robust NaN handling</li> <li>Stouffer\u2019s Z-score method for meta-analysis across studies or batches</li> <li>Cohen\u2019s d and Hedges\u2019 g effect size estimation with proper small-sample correction</li> <li>Flexible delta-beta computation with optional absolute values and index alignment</li> <li>Threshold-based filtering of DMS results supporting logFC, delta-beta, and directional constraints</li> <li>Fast, vectorized sliding-window DMR discovery with configurable gap merging and minimum CpG requirements</li> <li>Comprehensive DMR summarization and cross-dataset reproducibility metrics (Jaccard, concordance, Spearman correlation)</li> <li>Full preservation of CpG identifiers and genomic coordinates throughout all operations</li> </ul> <p><code>adjust_pvalues(pvals: Union[pandas.core.series.Series, ndarray, List[float]], method: str = 'fdr_bh') -&gt; pandas.core.series.Series</code></p> <p>Apply multiple-testing correction to raw p-values using statsmodels.</p> <p>Handles NaN values robustly (treated as non-significant) and preserves the     original index when input is a pandas Series.</p>"},{"location":"UserGuide/#parameters_38","title":"Parameters","text":"<ul> <li>pvals: <code>array-like</code>     Raw p-values (0 \u2264 p \u2264 1).</li> <li>method: <code>str, default \"fdr_bh\"</code>     Correction method passed to <code>statsmodels.stats.multitest.multipletests</code>.     Supported: <code>\"bonferroni\"</code>, <code>\"holm\"</code>, <code>\"fdr_bh\"</code>, <code>\"fdr_by\"</code>,         <code>\"sidak\"</code>, <code>\"none\"</code>.</li> </ul>"},{"location":"UserGuide/#returns_36","title":"Returns","text":"<p>pd.Series     Adjusted p-values with identical index/order as input.</p> <p><code>compute_delta_beta(mean_beta_group1: Union[pandas.core.series.Series, ndarray], mean_beta_group2: Union[pandas.core.series.Series, ndarray], as_abs: bool = False) -&gt; pandas.core.series.Series</code></p> <p>Calculate per-CpG difference in mean beta values between two groups.</p> <p>Automatically aligns inputs by index; supports absolute differences.</p>"},{"location":"UserGuide/#parameters_39","title":"Parameters","text":"<p>mean_beta_group1, mean_beta_group2 : Series-like     Group-wise mean beta values. - as_abs: <code>bool, default False</code>     Return absolute delta-beta if True.</p>"},{"location":"UserGuide/#returns_37","title":"Returns","text":"<p>pd.Series     Delta-beta values (positive = group1 &gt; group2).</p> <p><code>compute_dms_reproducibility(res1: DataFrame, res2: DataFrame, id_col: Optional[str] = None, effect_col: str = 'logFC', pval_col: str = 'padj', pval_thresh: float = 0.05) -&gt; Dict[str, Any]</code></p> <p>Quantify reproducibility of differential methylation signals across     two independent analyses or cohorts.</p> <p>Metrics include:</p> <ul> <li>Total/overlap feature counts</li> <li>Jaccard index</li> <li>Number of overlapping significant CpGs</li> <li>Directional concordance</li> <li>Spearman correlation of effect sizes</li> </ul>"},{"location":"UserGuide/#parameters_40","title":"Parameters","text":"<p>res1, res2 : pd.DataFrame     Two differential result tables (same CpG index preferred). effect_col, pval_col : str     Columns for effect size and adjusted p-value. - pval_thresh: <code>float, default 0.05</code></p>"},{"location":"UserGuide/#returns_38","title":"Returns","text":"<p>dict     Comprehensive reproducibility statistics.</p> <p><code>compute_effect_size(beta_group1: DataFrame, beta_group2: DataFrame, method: str = 'cohens_d') -&gt; pandas.core.series.Series</code></p> <p>Compute standardized effect size (Cohen\u2019s d or Hedges\u2019 g) for each CpG     between two groups.</p> <p>Uses pooled standard deviation with proper small-sample correction for Hedges\u2019 g.</p>"},{"location":"UserGuide/#parameters_41","title":"Parameters","text":"<p>beta_group1, beta_group2 : pd.DataFrame     Beta matrices (CpGs \u00d7 samples) for each group. - method: <code>{\"cohens_d\", \"hedges_g\"}, default \"cohens_d\"</code></p>"},{"location":"UserGuide/#returns_39","title":"Returns","text":"<p>pd.Series     Effect size per CpG (positive = higher in group1).</p> <p><code>filter_dms(res: DataFrame, lfc_col: str = 'logFC', pval_col: str = 'padj', delta_beta_col: Optional[str] = None, pval_thresh: float = 0.05, lfc_thresh: float = 0.0, delta_beta_thresh: Optional[float] = None, direction: Optional[str] = None) -&gt; DataFrame</code></p> <p>Apply multi-criterion filtering to differential methylation results.</p> <ul> <li>Supports: <code>- Adjusted p-value threshold</code></li> <li>Minimum |logFC|</li> <li>Minimum |\u0394\u03b2|</li> <li>Directional filtering (\u201chyper\u201d or \u201chypo\u201d)</li> </ul>"},{"location":"UserGuide/#parameters_42","title":"Parameters","text":"<ul> <li>res: <code>pd.DataFrame</code>     Differential results table. lfc_col, pval_col, delta_beta_col : str     Column names (defaults: \"logFC\", \"padj\", optional). pval_thresh, lfc_thresh, delta_beta_thresh     Numeric thresholds.</li> <li>direction: <code>{\"hyper\", \"hypo\", None}</code></li> </ul>"},{"location":"UserGuide/#returns_40","title":"Returns","text":"<p>pd.DataFrame     Subset of rows passing all specified criteria.</p> <p><code>find_dmrs_by_sliding_window(dms: DataFrame, annotation: DataFrame, chr_col: str = 'chr', pos_col: str = 'pos', pval_col: str = 'padj', pval_thresh: float = 0.05, delta_beta_col: Optional[str] = 'delta_beta', max_gap: int = 500, min_cpgs: int = 3, merge_distance: Optional[int] = None, use_intervaltree: bool = True) -&gt; DataFrame</code></p> <p>Identify differentially methylated regions (DMRs) by clustering spatially     proximate significant CpGs.</p> <p>Uses a fast sliding-window/gap-merging approach per chromosome.</p>"},{"location":"UserGuide/#parameters_43","title":"Parameters","text":"<ul> <li>dms: <code>pd.DataFrame</code>     Significant DMS results (after filtering).</li> <li>annotation: <code>pd.DataFrame</code>     CpG annotation with <code>chr</code> and <code>pos</code> columns.</li> <li>max_gap: <code>int, default 500</code>     Maximum distance (bp) to bridge adjacent significant CpGs.</li> <li>min_cpgs: <code>int, default 3</code>     Minimum number of significant CpGs required to call a DMR.</li> <li>merge_distance: <code>int or None</code>     If set, merge DMRs closer than this distance.</li> </ul>"},{"location":"UserGuide/#returns_41","title":"Returns","text":"<p>pd.DataFrame     One row per DMR with columns:     <code>chr</code>, <code>start</code>, <code>end</code>, <code>n_cpgs</code>, <code>mean_delta_beta</code>,         <code>mean_logFC</code>, <code>min_padj</code>, <code>cpgs</code> (list).</p> <p><code>stouffer_combined_pvalue(pvals)</code></p> <p>Combine independent p-values across studies or replicates using Stouffer\u2019s     Z-score method (equal weighting).</p>"},{"location":"UserGuide/#parameters_44","title":"Parameters","text":"<ul> <li>pvals: <code>array-like</code>     List or array of p-values to combine.</li> </ul>"},{"location":"UserGuide/#returns_42","title":"Returns","text":"<p>float     Single combined p-value.</p>"},{"location":"UserGuide/#raises_15","title":"Raises","text":"<p>ValueError     If input is empty or contains values outside [0, 1].</p> <p><code>summarize_regions(dmrs: DataFrame, summary_cols: Optional[List[str]] = None) -&gt; DataFrame</code></p> <p>Generate a concise summary table of discovered DMRs.</p> <p>Reports total count, median length, average CpG density, mean delta-beta,     and strongest significance.</p>"},{"location":"UserGuide/#parameters_45","title":"Parameters","text":"<ul> <li>dmrs: <code>pd.DataFrame</code>     Output from <code>find_dmrs_by_sliding_window</code>.</li> <li>summary_cols: <code>list[str] or None</code>     Columns to summarize (defaults to key metrics).</li> </ul>"},{"location":"UserGuide/#returns_43","title":"Returns","text":"<p>pd.DataFrame     Single-row summary suitable for manuscript tables.</p>"},{"location":"UserGuide/#helpers","title":"Helpers","text":"<p>General-purpose utilities for DNA methylation analysis workflows.</p> <p>This lightweight module contains essential helper functions used across the DMeth package for consistent data handling and summarization. It provides robust chromosome string normalization and flexible group-wise aggregation of beta-value matrices, ensuring compatibility and reproducibility in downstream statistical and annotation steps.</p>"},{"location":"UserGuide/#features_9","title":"Features","text":"<ul> <li>Robust chromosome identifier normalization with automatic 'chr' prefix addition and preservation of X/Y conventions</li> <li>Safe handling of mixed chromosome formats (e.g., '1', 'chr1', 'CHR1' \u2192 'chr1', 'chrX')</li> <li>Efficient group-wise summarization of per-sample beta values with support for arbitrary aggregation functions</li> <li>Automatic computation of both mean and variance per group for interpretability and modeling</li> <li>Graceful handling of missing groups, empty inputs, and non-overlapping sample sets</li> <li>Index-preserving operations fully compatible with CpG \u00d7 sample matrix conventions</li> </ul> <p><code>summarize_groups(beta: DataFrame, groups: pandas.core.series.Series, summary_func: Callable = &lt;function mean at 0x10a87f5ec730&gt;) -&gt; DataFrame</code></p> <p>Compute group-wise summary statistics (mean and variance) across samples     for a beta-value matrix.</p> <p>Designed for rapid interpretation of methylation levels across     experimental conditions or cell types.</p>"},{"location":"UserGuide/#parameters_46","title":"Parameters","text":"<ul> <li>beta: <code>pd.DataFrame</code>     Beta-value matrix with CpGs as rows (index) and samples as columns.</li> <li>groups: <code>pd.Series</code>     Sample-to-group mapping. Index must align with <code>beta.columns</code>.</li> <li>summary_func: `callable, default <code>np.mean```     Aggregation function applied per group (e.g.,</code>np.mean<code>,</code>np.median``).</li> </ul>"},{"location":"UserGuide/#returns_44","title":"Returns","text":"<p>pd.DataFrame     New DataFrame with columns:     <code>mean_{group}</code> \u2013 group-wise summary using <code>summary_func</code> <code>var_{group}</code>  \u2013 sample variance within each group (ddof=1)</p> <pre><code>Missing groups or empty intersections yield ``NaN`` columns.\n</code></pre>"},{"location":"UserGuide/#notes_10","title":"Notes","text":"<ul> <li>Fully preserves CpG index.</li> <li>Handles partial or missing group overlap gracefully.</li> <li>Ideal for generating input tables for delta-beta calculation,     visualization, or reporting.</li> </ul>"},{"location":"UserGuide/#signature","title":"Signature","text":"<p>Biomarker signature discovery and predictive modeling for DNA methylation data.</p> <p>This module provides a streamlined, production-ready framework for translating differential methylation results into high-performance diagnostic, prognostic, or predictive biomarker panels. It supports feature selection from statistical outputs, cross-validated model training with state-of-the-art algorithms, and rigorous independent validation of classification or regression performance.</p>"},{"location":"UserGuide/#features_10","title":"Features","text":"<ul> <li>Simple yet effective signature selection via top-ranked CpGs by p-value or moderated t-statistic</li> <li>Flexible predictive modeling with Random Forest and Elastic Net (with built-in hyperparameter tuning via CV)</li> <li>Automatic task detection and appropriate stratification (classification vs regression)</li> <li>Comprehensive cross-validation and held-out test set evaluation with standard metrics (AUC, accuracy, R\u00b2, RMSE)</li> <li>Full integration with DMeth result tables and sample-level beta matrices (features \u00d7 samples orientation)</li> <li>Reproducible training through fixed random seeds and stratified splitting</li> <li>Extensible architecture for future stability selection, recursive feature elimination, or multi-omics integration</li> </ul> <p><code>model_dms_for_prediction(beta: 'pd.DataFrame', labels: 'pd.Series', method: 'str' = 'random_forest', n_splits: 'int' = 5, random_state: 'int' = 42, task: 'Optional[str]' = None) -&gt; 'Dict[str, Any]'</code></p> <p>Train and evaluate a predictive model using DNA methylation signatures.</p> <p>Automatically detects classification vs regression tasks and applies     appropriate modeling and evaluation strategies.</p>"},{"location":"UserGuide/#parameters_47","title":"Parameters","text":"<ul> <li>beta: <code>pd.DataFrame</code>     Beta-value matrix with CpGs as rows and samples as columns (features \u00d7         samples orientation).</li> <li>labels: <code>pd.Series</code>     Target variable aligned with <code>beta.columns</code>.</li> <li>method: <code>{\"random_forest\", \"elasticnet\"}, default \"random_forest\"</code>     Predictive algorithm:     <code>random_forest</code>: 500 trees with parallel training     <code>elasticnet</code>: LogisticRegressionCV or ElasticNetCV with built-in         cross-validated regularization</li> <li>n_splits: <code>int, default 5</code>     Number of cross-validation folds for hyperparameter tuning and         performance estimation.</li> <li>random_state: <code>int, default 42</code>     Seed for reproducible splitting and model initialization.</li> <li>task: <code>{\"classification\", \"regression\"} or None, optional</code>     Force task type. If <code>None</code>, inferred from label distribution.</li> </ul>"},{"location":"UserGuide/#returns_45","title":"Returns","text":"<p>dict     Contains:     <code>estimator</code>: final fitted model (trained on full data)     <code>cv_results</code>: detailed cross-validation scores     <code>test_auc</code> / <code>test_accuracy</code> (classification) or <code>test_rmse</code>         / <code>test_r2</code> (regression) on a stratified 20% held-out set</p> <p><code>select_signature_panel(res: 'pd.DataFrame', method: 'str' = 'top', top_n: 'int' = 100, importance_col: 'str' = 't') -&gt; 'List[str]'</code></p> <p>Extract a candidate biomarker panel from differential methylation results.</p>"},{"location":"UserGuide/#parameters_48","title":"Parameters","text":"<ul> <li>res: <code>pd.DataFrame</code>     Differential analysis results table (e.g., output from <code>fit_differential</code>).     Must contain at least one of <code>pval</code> or the column specified in         <code>importance_col</code>.</li> <li>method: <code>str, default \"top\"</code>     Feature selection strategy. Currently only <code>\"top\"</code> is implemented.</li> <li>top_n: <code>int, default 100</code>     Number of top-ranked CpGs to retain.</li> <li>importance_col: <code>str, default \"t\"</code>     Column used for ranking when <code>pval</code> is unavailable (e.g., moderated         t-statistic).</li> </ul>"},{"location":"UserGuide/#returns_46","title":"Returns","text":"<p>List[str]     Ordered list of selected CpG identifiers (row names from <code>res</code>).</p>"},{"location":"UserGuide/#notes_11","title":"Notes","text":"<ul> <li>Prioritizes <code>pval</code> for ranking if present.</li> <li>Falls back to descending order of <code>importance_col</code> otherwise.</li> <li>Future extensions will include stability selection and recursive     feature elimination.</li> </ul> <p><code>validate_signature(X_train: 'pd.DataFrame', y_train: 'Union[pd.Series, np.ndarray]', X_test: 'pd.DataFrame', y_test: 'Union[pd.Series, np.ndarray]', features: 'Sequence[str]', method: 'str' = 'elasticnet') -&gt; 'Dict[str, Any]'</code></p> <p>Independent validation of a pre-selected methylation signature on held-out data.</p> <p>Re-trains the specified model on training data using only the provided     features and reports performance on a separate test set.</p>"},{"location":"UserGuide/#parameters_49","title":"Parameters","text":"<p>X_train, X_test : pd.DataFrame     Training and test methylation matrices (samples \u00d7 features). y_train, y_test : array-like     Corresponding labels. - features: <code>Sequence[str]</code>     Subset of CpGs constituting the signature. - method: <code>str, default \"elasticnet\"</code>     Model used for validation (same options as <code>model_dms_for_prediction</code>).</p>"},{"location":"UserGuide/#returns_47","title":"Returns","text":"<p>dict     Performance metrics:     Binary classification \u2192 <code>auc</code> and <code>accuracy</code>     Multi-class/regression \u2192 <code>accuracy</code> or <code>rmse</code> + <code>r2</code></p>"},{"location":"UserGuide/#notes_12","title":"Notes","text":"<p>Provides an unbiased estimate of clinical/translational performance     when the signature was derived on a separate discovery cohort.</p>"},{"location":"UserGuide/#configuration","title":"Configuration","text":""},{"location":"UserGuide/#config-manager","title":"Config Manager","text":"<p>Planner configuration manager for DNA methylation studies.</p> <ul> <li>Provides a thread-safe singleton (<code>PlannerConfig</code>) that centralizes platforms, experimental designs, cost components, timeline phases, and global settings.</li> <li>All configurations are strictly validated with Pydantic models and can be atomically loaded from or saved to multiple formats (JSON, YAML, TOML, Python literals, Excel/CSV tables).</li> </ul>"},{"location":"UserGuide/#features_11","title":"Features","text":"<ul> <li>Global singleton accessible via <code>get_config()</code></li> <li>Atomic file load/save with automatic merging over built-in defaults</li> <li>Full Pydantic validation on every load and modification</li> <li>Excel/CSV sheet-based overrides (Platforms, Designs, Costs, Timeline)</li> <li>Power-analysis-based sample size calculation with Bonferroni/FDR correction</li> <li>Timeline and cost estimation helpers</li> <li>In-place configuration migration facility</li> </ul> <p><code>CostComponentSchema(*, cost: Annotated[float, Ge(ge=0)], unit: Annotated[str, _PydanticGeneralMetadata(pattern='^(per_sample|per_cpg|fixed)$')], description: Optional[str] = None, optional: bool = False, applies_to: Optional[List[str]] = None) -&gt; None</code></p> <p>No docstring provided.</p> <p><code>DesignSchema(*, name: str, description: Optional[str] = None, n_groups: Annotated[int, Ge(ge=1)], paired: bool = False, complexity: Optional[str] = None, min_n_recommended: Annotated[int, Ge(ge=1)], power_adjustment: Annotated[float, Gt(gt=0)], analysis_method: Optional[str] = None, example_uses: Optional[List[str]] = None) -&gt; None</code></p> <p>No docstring provided.</p> <p><code>GlobalSettingsSchema(*, contingency_buffer_percent: Annotated[float, Ge(ge=0.0), Le(le=100.0)] = 10.0, default_mcp_method: Annotated[str, _PydanticGeneralMetadata(pattern='^(bonferroni|fdr|none)$')] = 'fdr') -&gt; None</code></p> <p>No docstring provided.</p> <p><code>PlannerConfig(config_file: Union[str, pathlib.Path, NoneType] = None)</code></p> <p>Thread-safe singleton holding the complete planner configuration.</p> <p>The singleton pattern ensures that only one configuration instance exists throughout the application lifetime. Access is recommended via the <code>get_config()</code> function.</p>"},{"location":"UserGuide/#parameters_50","title":"Parameters","text":"<ul> <li>config_file: <code>str or Path, optional</code>     Configuration file to load immediately after instantiation.</li> </ul> <p><code>PlannerConfigModel(*, platforms: Dict[str, dmeth.config.config_manager.PlatformSchema], designs: Dict[str, dmeth.config.config_manager.DesignSchema], cost_components: Dict[str, dmeth.config.config_manager.CostComponentSchema], timeline_phases: Dict[str, dmeth.config.config_manager.TimelinePhaseSchema], global_settings: Optional[dmeth.config.config_manager.GlobalSettingsSchema] = GlobalSettingsSchema(contingency_buffer_percent=10.0, default_mcp_method='fdr')) -&gt; None</code></p> <p>No docstring provided.</p> <p><code>PlatformSchema(*, name: str, manufacturer: Optional[str] = None, n_cpgs: Annotated[int, Ge(ge=1)], cost_per_sample: Annotated[float, Ge(ge=0)], processing_days: Annotated[int, Ge(ge=0)], dna_required_ng: Optional[float] = None, coverage: Optional[str] = None, release_year: Optional[int] = None, status: Optional[str] = None, recommended: bool = False, notes: Optional[str] = None) -&gt; None</code></p> <p>No docstring provided.</p> <p><code>TimelinePhaseSchema(*, name: Optional[str] = None, base_duration_days: Annotated[float, Gt(gt=0)], scaling_factor: Optional[float] = 0.0, batch_adjustment: Optional[float] = 0.0, description: Optional[str] = None, critical: bool = False, optional: bool = False, parallelizable: bool = False) -&gt; None</code></p> <p>No docstring provided.</p> <p><code>get_config() -&gt; dmeth.config.config_manager.PlannerConfig</code></p> <p>Retrieve the global singleton instance of <code>PlannerConfig</code>.</p> <p>The instance is created on first access if necessary.</p>"},{"location":"UserGuide/#returns_48","title":"Returns","text":"<p>PlannerConfig     The active configuration object.</p> <p><code>load_file(path: Union[str, pathlib.Path], allow_excel: bool = True) -&gt; None</code></p> <p>Load and validate a configuration file, merging it with built-in defaults.</p> <p>Supported formats are JSON, YAML, TOML, Python literal dictionaries, and Excel/CSV table files. The loaded data is deeply merged over the defaults and then validated against the Pydantic schema.</p>"},{"location":"UserGuide/#parameters_51","title":"Parameters","text":"<ul> <li>path: <code>str or Path</code>     Path to the configuration file.</li> <li>allow_excel: <code>bool, default True</code>     Permit loading from Excel (.xlsx, .xls) or CSV files.</li> </ul>"},{"location":"UserGuide/#raises_16","title":"Raises","text":"<p>FileNotFoundError     If the specified file does not exist. PermissionError     If the file cannot be read. ValueError     If the file format is unsupported or malformed. ValidationError     If the merged configuration fails schema validation.</p> <p><code>load_from_table_file(path: pathlib.Path) -&gt; Dict[str, Any]</code></p> <p>Parse configuration fragments from an Excel workbook or CSV file.</p> <p>Recognised sheets/tables are:</p> <ul> <li>Platforms</li> <li>Designs</li> <li>Costs (mapped to <code>cost_components</code>)</li> <li>Timeline (mapped to <code>timeline_phases</code>)</li> </ul> <p>The function returns a dictionary containing only the sections that could be successfully interpreted.</p>"},{"location":"UserGuide/#parameters_52","title":"Parameters","text":"<ul> <li>path: <code>Path</code>     Path to the Excel or CSV file.</li> </ul>"},{"location":"UserGuide/#returns_49","title":"Returns","text":"<p>dict     Partial configuration with keys <code>platforms</code>, <code>designs</code>,     <code>cost_components</code>, and/or <code>timeline_phases</code>.</p>"},{"location":"UserGuide/#raises_17","title":"Raises","text":"<p>ValueError     If no recognised configuration tables are found.</p> <p><code>migrate(migrator_callable) -&gt; None</code></p> <p>Apply an in-place migration to the active configuration.</p> <p>The provided callable receives a copy of the current raw configuration and must return an updated dictionary. The result is merged, validated, and activated.</p>"},{"location":"UserGuide/#parameters_53","title":"Parameters","text":"<ul> <li>migrator_callable: <code>callable</code>     Function <code>raw_config -&gt; updated_config</code>.</li> </ul> <p><code>reload() -&gt; None</code></p> <p>Reload the currently-loaded configuration file.</p> <p>If no file was loaded earlier, this re-validates the in-memory config.</p> <p><code>reset_config()</code></p> <p>Destroy the current singleton instance (primarily for testing).</p> <p><code>save_file(path: Union[str, pathlib.Path], fmt: Optional[str] = None) -&gt; None</code></p> <p>Atomically save the current configuration to a file.</p> <p>The format is inferred from the file extension unless <code>fmt</code> is provided.</p> <p>Supported formats: JSON (default), YAML, TOML.</p>"},{"location":"UserGuide/#parameters_54","title":"Parameters","text":"<ul> <li>path: <code>str or Path</code>     Destination file path.</li> <li>fmt: <code>str, optional</code>     Explicit format (<code>json</code>, <code>yaml</code>, <code>toml</code>).</li> </ul>"},{"location":"UserGuide/#raises_18","title":"Raises","text":"<p>ValueError     If the requested format is not supported. RuntimeError     If a required library (PyYAML or toml) is missing.</p>"},{"location":"UserGuide/#inputoutput","title":"Input/Output","text":""},{"location":"UserGuide/#data-utils","title":"Data Utils","text":"<p>Core data structures and validation utilities for the DMeth pipeline.</p> <p>This module defines the central ProcessedData container used throughout the package and provides helper functions for ensuring data integrity (index alignment and type safety).</p>"},{"location":"UserGuide/#key-components","title":"Key Components","text":"<p>ProcessedData</p> <ul> <li> <p>The standard container holding aligned methylation matrix, sample metadata, and probe annotation. All analysis functions expect this object.</p> </li> <li> <p>Validation helpers:</p> <ul> <li><code>_ensure_index_alignment(M, pheno, ann)</code>     Checks that samples and probes are consistently indexed across components.</li> <li><code>_ensure_index_strings(df)</code>     Safely converts DataFrame indices, but not columns, to strings (required         for HDF5/h5py compatibility).</li> </ul> </li> </ul> <p>All ProcessedData objects are automatically validated and string-indexed upon creation.</p> <p><code>ProcessedData(M: DataFrame, pheno: DataFrame, ann: DataFrame, meta: Dict[str, Any] = &lt;factory&gt;) -&gt; None</code></p> <p>Central container for aligned methylation data used throughout the DMeth pipeline.</p> <p>Guarantees that:</p> <ul> <li>All components (methylation matrix, sample metadata, probe annotation)     share consistent string indices.</li> <li>Sample and probe alignment is validated on construction.</li> <li>A <code>meta</code> dictionary tracks processing history (normalisation,     batch correction, QC metrics, etc.).</li> </ul> <p>All downstream functions expect or return instances of this class.</p>"},{"location":"UserGuide/#parameters_55","title":"Parameters","text":"<ul> <li>M: <code>pd.DataFrame</code>     Methylation matrix with CpG sites as rows and samples as columns.     Values are typically beta (0\u20131) or M-values (-inf to +inf).</li> <li>pheno: <code>pd.DataFrame</code>     Sample metadata table. Must be indexed by sample IDs (strings         after construction).</li> <li>ann: <code>pd.DataFrame or None</code>     Optional probe/CpG annotation table (e.g., Illumina manifest).         Must be indexed by CpG IDs.     If <code>None</code>, probe-level alignment checks are skipped.</li> <li>meta: <code>dict, optional</code>     Free-form dictionary storing pipeline provenance and parameters.     Pre-populated with sensible defaults if not provided.</li> </ul>"},{"location":"UserGuide/#attributes_1","title":"Attributes","text":"<ul> <li>M: <code>pd.DataFrame</code>     Methylation matrix (string-indexed rows and columns).</li> <li>pheno: <code>pd.DataFrame</code>     Sample metadata (string-indexed).</li> <li>ann: <code>pd.DataFrame or None</code>     Probe annotation (string-indexed if present).</li> <li>meta: <code>dict</code>     Processing metadata (e.g., <code>{\"matrix_type\": \"beta\",         \"normalized\": True, ...}</code>).</li> </ul>"},{"location":"UserGuide/#notes_13","title":"Notes","text":"<p>The <code>__post_init__</code> method automatically:</p> <ul> <li>Converts all relevant indices to strings.</li> <li>Validates alignment between components.</li> <li>Raises informative <code>KeyError</code> on mismatch.</li> </ul>"},{"location":"UserGuide/#readers","title":"Readers","text":"<p>Input utilities for loading methylation datasets in the DMeth pipeline.</p> <p>This module provides a Python API for loading preprocessed or raw methylation data into the standard :class:<code>ProcessedData</code> container used throughout the package.</p>"},{"location":"UserGuide/#features_12","title":"Features","text":"<ul> <li>Robust multi-format reading (CSV, TSV, Excel, pickle, HDF5, Parquet, Feather)</li> <li>Automatic coercion of methylation matrix to numeric values</li> <li>Smart HDF5 key selection (prefers <code>/M</code> or <code>M</code>)</li> <li>Safe sample alignment between methylation matrix and phenotype data</li> <li>Two high-level entry points:<ul> <li><code>load_processed_data()</code> \u2013 load a previously saved <code>ProcessedData</code> object</li> <li><code>load_methylation_data()</code> \u2013 construct a new <code>ProcessedData</code> from raw files</li> </ul> </li> </ul> <p><code>ProcessedData(M: DataFrame, pheno: DataFrame, ann: DataFrame, meta: Dict[str, Any] = &lt;factory&gt;) -&gt; None</code></p> <p>Central container for aligned methylation data used throughout the DMeth pipeline.</p> <p>Guarantees that:</p> <ul> <li>All components (methylation matrix, sample metadata, probe annotation)     share consistent string indices.</li> <li>Sample and probe alignment is validated on construction.</li> <li>A <code>meta</code> dictionary tracks processing history (normalisation,     batch correction, QC metrics, etc.).</li> </ul> <p>All downstream functions expect or return instances of this class.</p>"},{"location":"UserGuide/#parameters_56","title":"Parameters","text":"<ul> <li>M: <code>pd.DataFrame</code>     Methylation matrix with CpG sites as rows and samples as columns.     Values are typically beta (0\u20131) or M-values (-inf to +inf).</li> <li>pheno: <code>pd.DataFrame</code>     Sample metadata table. Must be indexed by sample IDs (strings         after construction).</li> <li>ann: <code>pd.DataFrame or None</code>     Optional probe/CpG annotation table (e.g., Illumina manifest).         Must be indexed by CpG IDs.     If <code>None</code>, probe-level alignment checks are skipped.</li> <li>meta: <code>dict, optional</code>     Free-form dictionary storing pipeline provenance and parameters.     Pre-populated with sensible defaults if not provided.</li> </ul>"},{"location":"UserGuide/#attributes_2","title":"Attributes","text":"<ul> <li>M: <code>pd.DataFrame</code>     Methylation matrix (string-indexed rows and columns).</li> <li>pheno: <code>pd.DataFrame</code>     Sample metadata (string-indexed).</li> <li>ann: <code>pd.DataFrame or None</code>     Probe annotation (string-indexed if present).</li> <li>meta: <code>dict</code>     Processing metadata (e.g., <code>{\"matrix_type\": \"beta\",         \"normalized\": True, ...}</code>).</li> </ul>"},{"location":"UserGuide/#notes_14","title":"Notes","text":"<p>The <code>__post_init__</code> method automatically:</p> <ul> <li>Converts all relevant indices to strings.</li> <li>Validates alignment between components.</li> <li>Raises informative <code>KeyError</code> on mismatch.</li> </ul> <p><code>load_methylation_data(methylation_input: Union[str, pathlib.Path, DataFrame], pheno_input: Union[str, pathlib.Path, DataFrame, NoneType] = None, ann_input: Union[str, pathlib.Path, DataFrame, NoneType] = None, index_col_probe: Optional[int] = 0, index_col_sample: Optional[int] = 0) -&gt; ProcessedData</code></p> <p>High-level constructor that builds a ProcessedData object from     raw matrix/metadata files.</p> <ul> <li>Accepts file paths, already-loaded DataFrames, or a mix of both.</li> <li>Performs automatic type coercion, sample alignment, and validation.</li> </ul>"},{"location":"UserGuide/#parameters_57","title":"Parameters","text":"<ul> <li>methylation_input: <code>str | Path | pd.DataFrame</code>     CpG \u00d7 sample methylation matrix (beta or M-values).</li> <li>pheno_input: <code>str | Path | pd.DataFrame, optional</code>     Sample phenotype/metadata table. If <code>None</code>, an empty placeholder indexed by     the matrix columns is created.</li> <li>ann_input: <code>str | Path | pd.DataFrame, optional</code>     CpG probe annotation (e.g., Illumina manifest). If <code>None</code>,         annotation is omitted.</li> <li>index_col_probe: <code>int, default 0</code>     Column containing CpG identifiers when reading the methylation matrix.</li> <li>index_col_sample: <code>int, default 0</code>     Column containing sample identifiers when reading the phenotype table.</li> </ul>"},{"location":"UserGuide/#returns_50","title":"Returns","text":"<p>ProcessedData     Fully validated container ready for downstream analysis.</p>"},{"location":"UserGuide/#notes_15","title":"Notes","text":"<ul> <li>Non-numeric entries in the methylation matrix are forcibly coerced to NaN   (with a warning indicating how many values were affected).</li> <li>The phenotype table is reindexed to exactly match the sample order in <code>M</code>.</li> <li>All indices are converted to strings and alignment is checked by     <code>ProcessedData.__post_init__</code>.</li> </ul> <p><code>load_processed_data(path: Union[str, pathlib.Path], trusted: bool = False) -&gt; ProcessedData</code></p> <p>Load a previously saved ProcessedData object from disk.</p> <p>Supports the two canonical DMeth output formats: - <code>.pkl</code> / <code>.pickle</code> \u2192 direct pandas pickle of the ProcessedData instance - <code>.h5</code> / <code>.hdf5</code> \u2192 HDF5 store containing the keys <code>M</code>,     <code>pheno</code>, and optionally <code>ann</code></p>"},{"location":"UserGuide/#parameters_58","title":"Parameters","text":"<ul> <li>path: <code>str or Path</code>     Path to the saved ProcessedData file.</li> <li>trusted: <code>bool, default False</code>     Only allow <code>.pkl</code> / <code>.pickle</code> files from trusted sources</li> </ul>"},{"location":"UserGuide/#returns_51","title":"Returns","text":"<p>ProcessedData     Fully reconstructed and validated ProcessedData container.</p>"},{"location":"UserGuide/#raises_19","title":"Raises","text":"<p>ValueError     If pickle file is from an untrusted source ValueError     If the file extension is not one of the supported formats.</p>"},{"location":"UserGuide/#writers","title":"Writers","text":"<p>Output utilities for saving processed methylation data and analysis results.</p> <p>This module provides a unified interface (Python API + Typer CLI) for exporting:</p> <ul> <li>ProcessedData objects in multiple formats</li> <li>Differential methylation results (filtered and clean)</li> <li>IDAT-style HDF5 archives (compatible with downstream tools)</li> <li>Self-contained HTML analysis reports with embedded plots</li> </ul> <p>All export functions include overwrite protection, automatic directory creation, and informative logging.</p>"},{"location":"UserGuide/#features_13","title":"Features","text":"<ul> <li>Smart format detection and suffix handling</li> <li>Optional compression (blosc:zstd or gzip)</li> <li>Safe export of differential results (core columns + group means)</li> <li>IDAT-compatible HDF5 layout via h5py (fallback to pandas HDFStore)</li> <li>One-call HTML report generation from summary dict + matplotlib figures</li> </ul> <p><code>ProcessedData(M: DataFrame, pheno: DataFrame, ann: DataFrame, meta: Dict[str, Any] = &lt;factory&gt;) -&gt; None</code></p> <p>Central container for aligned methylation data used throughout the DMeth pipeline.</p> <p>Guarantees that:</p> <ul> <li>All components (methylation matrix, sample metadata, probe annotation)     share consistent string indices.</li> <li>Sample and probe alignment is validated on construction.</li> <li>A <code>meta</code> dictionary tracks processing history (normalisation,     batch correction, QC metrics, etc.).</li> </ul> <p>All downstream functions expect or return instances of this class.</p>"},{"location":"UserGuide/#parameters_59","title":"Parameters","text":"<ul> <li>M: <code>pd.DataFrame</code>     Methylation matrix with CpG sites as rows and samples as columns.     Values are typically beta (0\u20131) or M-values (-inf to +inf).</li> <li>pheno: <code>pd.DataFrame</code>     Sample metadata table. Must be indexed by sample IDs (strings         after construction).</li> <li>ann: <code>pd.DataFrame or None</code>     Optional probe/CpG annotation table (e.g., Illumina manifest).         Must be indexed by CpG IDs.     If <code>None</code>, probe-level alignment checks are skipped.</li> <li>meta: <code>dict, optional</code>     Free-form dictionary storing pipeline provenance and parameters.     Pre-populated with sensible defaults if not provided.</li> </ul>"},{"location":"UserGuide/#attributes_3","title":"Attributes","text":"<ul> <li>M: <code>pd.DataFrame</code>     Methylation matrix (string-indexed rows and columns).</li> <li>pheno: <code>pd.DataFrame</code>     Sample metadata (string-indexed).</li> <li>ann: <code>pd.DataFrame or None</code>     Probe annotation (string-indexed if present).</li> <li>meta: <code>dict</code>     Processing metadata (e.g., <code>{\"matrix_type\": \"beta\",         \"normalized\": True, ...}</code>).</li> </ul>"},{"location":"UserGuide/#notes_16","title":"Notes","text":"<p>The <code>__post_init__</code> method automatically:</p> <ul> <li>Converts all relevant indices to strings.</li> <li>Validates alignment between components.</li> <li>Raises informative <code>KeyError</code> on mismatch.</li> </ul> <p><code>create_analysis_report(summary: Dict[str, Any], plots: Dict[str, matplotlib.figure.Figure], outpath: Union[str, pathlib.Path] = 'analysis_report.html', title: str = 'Methylation Analysis Report') -&gt; pathlib.Path</code></p> <p>Generate a self-contained, minimal HTML report embedding a JSON     summary and PNG images of supplied figures.</p> <p>Useful for quick sharing of results without requiring Jupyter or     additional dependencies.</p>"},{"location":"UserGuide/#parameters_60","title":"Parameters","text":"<ul> <li>summary: <code>dict</code>     Arbitrary summary statistics or results (JSON-serialisable).</li> <li>plots: <code>dict[str, plt.Figure]</code>     Mapping from plot name to Matplotlib figure objects.</li> <li>outpath: <code>str or Path, default \"analysis_report.html\"</code>     Output HTML file location.</li> <li>title: <code>str, default \"Methylation Analysis Report\"</code>     Top-level heading in the report.</li> </ul>"},{"location":"UserGuide/#returns_52","title":"Returns","text":"<p>Path     Path to the generated HTML file.</p> <p><code>export_idat_hdf5(beta: DataFrame, mvals: Optional[DataFrame], sample_sheet: Optional[DataFrame], filepath: Union[str, pathlib.Path], compress: bool = True) -&gt; pathlib.Path</code></p> <p>Write methylation data to an IDAT-compatible HDF5 archive using h5py     (preferred) or pandas fallback.</p> <p>Layout mirrors common downstream tools: groups <code>/beta</code>, <code>/mvals</code> (optional), and <code>/samples</code> containing one JSON dataset per sample.</p>"},{"location":"UserGuide/#parameters_61","title":"Parameters","text":"<ul> <li>beta: <code>pd.DataFrame</code>     Beta-value matrix (CpGs \u00d7 samples).</li> <li>mvals: <code>pd.DataFrame or None, optional</code>     M-value matrix (same dimensions).</li> <li>sample_sheet: <code>pd.DataFrame or None, optional</code>     Sample metadata (index = sample IDs).</li> <li>filepath: <code>str or Path</code>     Destination HDF5 file.</li> <li>compress: <code>bool, default True</code>     Apply gzip compression to large datasets.</li> </ul>"},{"location":"UserGuide/#returns_53","title":"Returns","text":"<p>Path     Path to the created HDF5 file.</p>"},{"location":"UserGuide/#raises_20","title":"Raises","text":"<p>RuntimeError     If neither h5py nor pandas.HDFStore is available.</p> <p><code>export_results(res: DataFrame, output_path: str, format: str = 'csv', include_all: bool = False, verbose: bool = True, overwrite: bool = True) -&gt; None</code></p> <p>Export differential methylation results to CSV, TSV, or Excel with     optional column filtering.</p> <ul> <li>By default only core statistical columns and per-group mean columns are exported.</li> <li>Overwrite protection is applied if <code>overwrite=False</code>.</li> </ul>"},{"location":"UserGuide/#parameters_62","title":"Parameters","text":"<ul> <li>res: <code>pd.DataFrame</code>     Differential results table (as returned by the analysis pipeline).</li> <li>output_path: <code>str</code>     Destination file path (extension determines format if <code>format</code> is omitted).</li> <li>format: <code>{\"csv\", \"tsv\", \"excel\"}, default \"csv\"</code>     Output file format.</li> <li>include_all: <code>bool, default False</code>     If True, export every column; if False, only core + mean columns are kept.</li> <li>verbose: <code>bool, default True</code>     Log a confirmation message on success.</li> <li>overwrite: <code>bool, default True</code>     Raise FileExistsError if the file exists and this is False.</li> </ul>"},{"location":"UserGuide/#raises_21","title":"Raises","text":"<p>FileExistsError     When <code>overwrite=False</code> and the target file already exists. ValueError     For unsupported <code>format</code>. RuntimeError     If writing fails (e.g., missing openpyxl for Excel).</p> <p><code>save_processed_data(data: 'ProcessedData', path: Union[str, pathlib.Path], format: str = 'hdf5', compression: str | None = 'blosc:zstd', complib_level: int = 9, overwrite: bool = True) -&gt; None</code></p> <p>Persist a ProcessedData object to disk in one of several convenient formats.</p>"},{"location":"UserGuide/#supported-formats","title":"Supported formats","text":"<p>csv / tsv      \u2192 three separate files (M, pheno, ann) xlsx           \u2192 single workbook with sheets \"M\", \"pheno\", \"ann\" pickle / pkl   \u2192 direct pickle of the ProcessedData instance hdf5 / h5      \u2192 pandas HDFStore with compressed tables</p>"},{"location":"UserGuide/#parameters_63","title":"Parameters","text":"<ul> <li>data: <code>ProcessedData</code>     The container to save.</li> <li>path: <code>str or Path</code>     Output path; suffix is automatically corrected to match <code>format</code>.</li> <li>format: <code>{\"csv\", \"tsv\", \"xlsx\", \"pickle\", \"pkl\", \"hdf5\", \"h5\"}, default \"hdf5\"</code>     Desired export format.</li> <li>compression: <code>str or None, default \"blosc:zstd\"</code>     Compression library for HDF5 (only used when format is hdf5).</li> <li>complib_level: <code>int, default 9</code>     Compression level (1\u20139) for HDF5.</li> <li>overwrite: <code>bool, default True</code>     Allow overwriting existing files.</li> </ul>"},{"location":"UserGuide/#raises_22","title":"Raises","text":"<p>ValueError     If an unsupported format is requested. FileExistsError     When <code>overwrite=False</code> and the target exists.</p>"},{"location":"UserGuide/#utilities","title":"Utilities","text":""},{"location":"UserGuide/#logger","title":"Logger","text":"<p>Centralised logging utilities for the DMeth DNA-methylation analysis suite.</p> <p>This module configures a unified logger with the following features:</p>"},{"location":"UserGuide/#features_14","title":"Features","text":"<ul> <li>Timestamped log files automatically saved to <code>&lt;output_dir&gt;/log/</code></li> <li>Simultaneous console (stdout) and file output</li> <li>Consistent formatting across all package modules</li> <li>A custom :class:<code>ProgressAwareLogger</code> that seamlessly integrates <code>tqdm</code> progress bars:<ul> <li><code>logger.progress(\"Processing samples\", total=n)</code> starts a progress bar</li> <li><code>logger.progress_update(k)</code> advances it</li> <li>Any regular log call (info/warning/error/etc.) automatically closes the active     bar so that log messages are never corrupted by overlapping tqdm output</li> </ul> </li> </ul> <p>All other <code>dmeth</code> modules import the logger via <code>get_logger()</code>.</p> <p><code>ProgressAwareLogger(name)</code></p> <p>Custom logger class that supports a temporary progress bar. The progress bar stays active until the next normal log call.</p> <p><code>get_logger(name: str = 'dmeth') -&gt; logging.Logger</code></p> <p>Return the central DMeth logger instance.</p>"},{"location":"UserGuide/#parameters_64","title":"Parameters","text":"<ul> <li>name: <code>str, default \"dmeth\"</code>     Logger name. Typically left as the default.</li> </ul>"},{"location":"UserGuide/#returns_54","title":"Returns","text":"<p>logging.Logger     The configured ProgressAwareLogger instance.</p>"},{"location":"UserGuide/#plotting","title":"Plotting","text":"<p>Plotting utilities for downstream DNA methylation analysis.</p> <p>This module provides a comprehensive set of visualisation functions for quality control, differential methylation analysis, dimensionality reduction, variance shrinkage diagnostics, and publication-ready summary figures. Functions operate on pandas DataFrames, ProcessedData objects, or differential methylation results and return standardised matplotlib (or optionally Plotly) figures.</p>"},{"location":"UserGuide/#features_15","title":"Features","text":"<ul> <li>Standardised figure creation</li> <li>Enhanced volcano plots with automatic significance colouring and annotation</li> <li>P-value QQ plots and histograms</li> <li>Sample-level PCA, t-SNE, and UMAP embeddings (static or interactive)</li> <li>Variance shrinkage diagnostics (limma-style)</li> <li>Mean-difference bar plots for top loci</li> <li>Multi-panel QC reports via plot_stage()</li> <li>Combined DMS/DMR summary visualisation (volcano + manhattan + heatmap)</li> </ul> <p><code>ProcessedData(M: DataFrame, pheno: DataFrame, ann: DataFrame, meta: Dict[str, Any] = &lt;factory&gt;) -&gt; None</code></p> <p>Central container for aligned methylation data used throughout the DMeth pipeline.</p> <p>Guarantees that:</p> <ul> <li>All components (methylation matrix, sample metadata, probe annotation)     share consistent string indices.</li> <li>Sample and probe alignment is validated on construction.</li> <li>A <code>meta</code> dictionary tracks processing history (normalisation,     batch correction, QC metrics, etc.).</li> </ul> <p>All downstream functions expect or return instances of this class.</p>"},{"location":"UserGuide/#parameters_65","title":"Parameters","text":"<ul> <li>M: <code>pd.DataFrame</code>     Methylation matrix with CpG sites as rows and samples as columns.     Values are typically beta (0\u20131) or M-values (-inf to +inf).</li> <li>pheno: <code>pd.DataFrame</code>     Sample metadata table. Must be indexed by sample IDs (strings         after construction).</li> <li>ann: <code>pd.DataFrame or None</code>     Optional probe/CpG annotation table (e.g., Illumina manifest).         Must be indexed by CpG IDs.     If <code>None</code>, probe-level alignment checks are skipped.</li> <li>meta: <code>dict, optional</code>     Free-form dictionary storing pipeline provenance and parameters.     Pre-populated with sensible defaults if not provided.</li> </ul>"},{"location":"UserGuide/#attributes_4","title":"Attributes","text":"<ul> <li>M: <code>pd.DataFrame</code>     Methylation matrix (string-indexed rows and columns).</li> <li>pheno: <code>pd.DataFrame</code>     Sample metadata (string-indexed).</li> <li>ann: <code>pd.DataFrame or None</code>     Probe annotation (string-indexed if present).</li> <li>meta: <code>dict</code>     Processing metadata (e.g., <code>{\"matrix_type\": \"beta\",         \"normalized\": True, ...}</code>).</li> </ul>"},{"location":"UserGuide/#notes_17","title":"Notes","text":"<p>The <code>__post_init__</code> method automatically:</p> <ul> <li>Converts all relevant indices to strings.</li> <li>Validates alignment between components.</li> <li>Raises informative <code>KeyError</code> on mismatch.</li> </ul> <p><code>correlate_methylation_expression(beta: 'pd.DataFrame', expression: 'pd.DataFrame', gene_map: 'Optional[Dict[str, str]]' = None, method: 'str' = 'pearson', override_index_alignment: 'bool' = False) -&gt; 'pd.DataFrame'</code></p> <p>Compute sample-wise correlation between CpG methylation and gene expression.</p> <p>Supports both one-to-one (same index) and many-to-one (custom CpG\u2192gene     mapping) scenarios.</p>"},{"location":"UserGuide/#parameters_66","title":"Parameters","text":"<p>beta, expression : pd.DataFrame     Methylation (CpGs \u00d7 samples) and expression (genes \u00d7 samples) matrices. - gene_map: <code>dict or None</code>     Explicit mapping from CpG ID \u2192 gene symbol (required for cis-analysis). - method: <code>{\"pearson\", \"spearman\"}, default \"pearson\"</code>     Correlation coefficient to compute. - override_index_alignment: <code>bool, default False</code>     Proceed even with &lt;2 overlapping samples (useful for exploratory checks).</p>"},{"location":"UserGuide/#returns_55","title":"Returns","text":"<p>pd.DataFrame     Correlation results with columns <code>r</code> and <code>pval</code> (indexed by CpG         and optionally gene).</p> <p><code>methylation_expression_heatmap(beta: DataFrame, expression: DataFrame, genes: Optional[List[str]] = None, top_n: int = 50, sample_metadata: Optional[DataFrame] = None, save_path: Union[str, pathlib.Path, NoneType] = None, method: str = 'pearson') -&gt; matplotlib.figure.Figure</code></p> <p>Heatmap of methylation-expression correlation coefficients for selected genes/CpGs.</p>"},{"location":"UserGuide/#parameters_67","title":"Parameters","text":"<ul> <li>beta: <code>pd.DataFrame</code>     Methylation beta matrix (features \u00d7 samples).</li> <li>expression: <code>pd.DataFrame</code>     Gene expression matrix (genes \u00d7 samples).</li> <li>genes: <code>list[str], optional</code>     Specific features to display; if None the top_n most correlated are used.</li> <li>top_n: <code>int, default 50</code>     Number of top correlations shown when <code>genes</code> is None.</li> <li>sample_metadata: <code>pd.DataFrame, optional</code>     Currently unused (reserved for future sample-side annotation).</li> <li>save_path: <code>str or Path, optional</code>     Destination for saving the figure.</li> <li>method: <code>{\"pearson\", \"spearman\"}, default \"pearson\"</code>     Correlation method.</li> </ul>"},{"location":"UserGuide/#returns_56","title":"Returns","text":"<p>plt.Figure     Horizontal heatmap of correlation coefficients.</p> <p><code>pca_plot(data: ProcessedData, color_col: str, title: str = 'PCA of Methylation Data', figsize: tuple[int, int] = (7, 6)) -&gt; None</code></p> <p>Display a simple PCA projection of samples coloured by a phenotype column.</p>"},{"location":"UserGuide/#parameters_68","title":"Parameters","text":"<ul> <li>data: <code>ProcessedData</code>     Container holding the methylation matrix and phenotype table.</li> <li>color_col: <code>str</code>     Column in <code>data.pheno</code> used for colouring points.</li> <li>title: <code>str, default \"PCA of Methylation Data\"</code>     Title shown on the plot.</li> <li>figsize: <code>tuple[int, int], default (7, 6)</code>     Size of the figure in inches.</li> </ul>"},{"location":"UserGuide/#notes_18","title":"Notes","text":"<p>The plot is shown immediately with <code>plt.show()</code> and is not returned.</p> <p><code>plot_mean_difference(beta_group1: DataFrame, beta_group2: DataFrame, top_n: int = 50, save_path: Union[str, pathlib.Path, NoneType] = None) -&gt; matplotlib.figure.Figure</code></p> <p>Bar plot of the largest absolute mean beta differences between two groups.</p>"},{"location":"UserGuide/#parameters_69","title":"Parameters","text":"<p>beta_group1, beta_group2 : pd.DataFrame     Beta-value matrices (features \u00d7 samples) for each group. - top_n: <code>int, default 50</code>     Number of top differentially methylated loci to display. - save_path: <code>str or Path, optional</code>     Destination for saving the figure.</p>"},{"location":"UserGuide/#returns_57","title":"Returns","text":"<p>plt.Figure     Bar chart of absolute mean differences.</p> <p><code>plot_pvalue_qq(res: DataFrame, pval_col: str = 'pval', dpi: int = 300, save_path: Union[str, pathlib.Path, NoneType] = None) -&gt; matplotlib.figure.Figure</code></p> <p>Produce a quantile-quantile plot comparing observed versus     expected -log10(p-values).</p>"},{"location":"UserGuide/#parameters_70","title":"Parameters","text":"<ul> <li>res: <code>pd.DataFrame</code>     DataFrame containing the p-value column.</li> <li>pval_col: <code>str, default \"pval\"</code>     Column name of the p-values.</li> <li>dpi: <code>int, default 300</code>     Figure resolution.</li> <li>save_path: <code>str or Path, optional</code>     Destination path for saving the figure.</li> </ul>"},{"location":"UserGuide/#returns_58","title":"Returns","text":"<p>plt.Figure     Q-Q plot figure.</p> <p><code>plot_shrinkage_diagnostics(s2: pandas.core.series.Series, s2_post: pandas.core.series.Series, d0: Optional[float] = None, save_path: Union[str, pathlib.Path, NoneType] = None) -&gt; matplotlib.figure.Figure</code></p> <p>Visualise the effect of empirical Bayes variance shrinkage.</p>"},{"location":"UserGuide/#parameters_71","title":"Parameters","text":"<ul> <li>s2: <code>pd.Series</code>     Original (unmoderated) variance estimates per feature.</li> <li>s2_post: <code>pd.Series</code>     Moderated (shrunk) variance estimates.</li> <li>d0: <code>float, optional</code>     Prior degrees of freedom from the shrinkage procedure (displayed         in title if given).</li> <li>save_path: <code>str or Path, optional</code>     If provided, the figure is saved to this location.</li> </ul>"},{"location":"UserGuide/#returns_59","title":"Returns","text":"<p>plt.Figure     Scatter plot comparing log10(original) vs log10(shrunk) variances.</p> <p><code>plot_stage(stage: str, M: DataFrame, res: Optional[DataFrame] = None, metadata: Optional[DataFrame] = None, groups_col: str = 'Type', top_n: int = 10, embedding: str = 'pca', interactive: bool = False, save_path: Union[str, Dict[str, str], NoneType] = None, dpi: int = 300, **kwargs) -&gt; Dict[str, Union[matplotlib.figure.Figure, ForwardRef('plotly.graph_objects.Figure')]]</code></p> <p>Orchestrate a complete multi-panel QC or analysis visualisation for     a given processing stage.</p> <p>Supported stages: \"qc\", \"variance\", \"differential\", \"top_hits\", \"correlation\".</p>"},{"location":"UserGuide/#parameters_72","title":"Parameters","text":"<ul> <li>stage: <code>str</code>     One of the recognised analysis stages.</li> <li>M: <code>pd.DataFrame</code>     Methylation matrix (features \u00d7 samples), typically M-values or beta-values.</li> <li>res: <code>pd.DataFrame, optional</code>     Differential methylation results (required for variance,         differential, top_hits stages).</li> <li>metadata: <code>pd.DataFrame, optional</code>     Sample annotation table; must contain the grouping column.</li> <li>groups_col: <code>str, default \"Type\"</code>     Column in metadata used for colour-coding samples.</li> <li>top_n: <code>int, default 10</code>     Number of top features to display in relevant panels.</li> <li>embedding: <code>{\"pca\", \"tsne\", \"umap\"}, default \"pca\"</code>     Dimensionality-reduction method for sample embedding.</li> <li>interactive: <code>bool, default False</code>     Return Plotly interactive figures where possible.</li> <li>save_path: <code>str, Path or dict, optional</code>     Path or mapping of figure names to paths for automatic saving.</li> <li>dpi: <code>int, default 300</code>     Resolution for static figures. **kwargs     Additional keyword arguments passed to the underlying reducer.</li> </ul>"},{"location":"UserGuide/#returns_60","title":"Returns","text":"<p>dict[str, plt.Figure | plotly.graph_objects.Figure]     Mapping from panel name to the generated figure(s).</p> <p><code>plot_volcano(res: DataFrame, lfc_col: str = 'logFC', pval_col: str = 'pval', alpha: float = 0.7, lfc_thresh: float = 1.0, pval_thresh: float = 0.05, top_n: int = 10, dpi: int = 300, save_path: Union[str, pathlib.Path, NoneType] = None) -&gt; matplotlib.figure.Figure</code></p> <p>Create an enhanced volcano plot with top hits annotated.</p>"},{"location":"UserGuide/#parameters_73","title":"Parameters","text":"<ul> <li>res: <code>pd.DataFrame</code>     Differential results with logFC and p-values</li> <li>lfc_col: <code>str</code>     Column name for log fold change</li> <li>pval_col: <code>str</code>     Column name for p-value</li> <li>alpha: <code>float</code>     Point transparency</li> <li>lfc_thresh: <code>float</code>     Threshold for logFC significance</li> <li>pval_thresh: <code>float</code>     Threshold for p-value significance</li> <li>top_n: <code>int</code>     Number of top hits to annotate</li> <li>dpi: <code>int</code>     Figure resolution</li> <li>save_path: <code>str or Path, optional</code>     Path to save figure</li> </ul>"},{"location":"UserGuide/#returns_61","title":"Returns","text":"<p>plt.Figure     Volcano plot figure</p> <p><code>pvalue_histogram(pvals: Union[pandas.core.series.Series, ndarray, List[float]], bins: int = 50, save_path: Union[str, pathlib.Path, NoneType] = None) -&gt; matplotlib.figure.Figure</code></p> <p>Histogram of p-values with a flat null-expectation line for QC assessment.</p>"},{"location":"UserGuide/#parameters_74","title":"Parameters","text":"<ul> <li>pvals: <code>array-like</code>     Collection of p-values.</li> <li>bins: <code>int, default 50</code>     Number of histogram bins.</li> <li>save_path: <code>str or Path, optional</code>     Path to save the figure.</li> </ul>"},{"location":"UserGuide/#returns_62","title":"Returns","text":"<p>plt.Figure     Histogram figure.</p> <p><code>visualize_dms(res: DataFrame, beta: Optional[DataFrame] = None, top_n: int = 50, volcano: bool = True, manhattan: bool = True, heatmap: bool = True, sample_metadata: Optional[DataFrame] = None, save_dir: Union[str, pathlib.Path, NoneType] = None) -&gt; Dict[str, Optional[matplotlib.figure.Figure]]</code></p> <p>Produce a standard set of summary plots for differentially methylated sites/regions.</p> <p>Optionally creates volcano, Manhattan, and heatmap visualisations.</p>"},{"location":"UserGuide/#parameters_75","title":"Parameters","text":"<ul> <li>res: <code>pd.DataFrame</code>     Differential methylation results.</li> <li>beta: <code>pd.DataFrame, optional</code>     Beta matrix required for the heatmap panel.</li> <li>top_n: <code>int, default 50</code>     Number of top CpGs shown in the heatmap. volcano / manhattan / heatmap : bool, default True     Toggle creation of each panel.</li> <li>sample_metadata: <code>pd.DataFrame, optional</code>     Sample annotation (currently unused but reserved for future clustering).</li> <li>save_dir: <code>str or Path, optional</code>     Directory where individual PNG files are written.</li> </ul>"},{"location":"UserGuide/#returns_63","title":"Returns","text":"<p>dict[str, plt.Figure | None]     Figures for \"volcano\", \"manhattan\", and \"heatmap\" (None if not generated).</p>"},{"location":"UserGuide/#citation","title":"Citation","text":"<p>If you use <code>dmeth</code> in your research, please cite:</p> <pre><code>@software{dmeth2025,\n  author = {Afolabi, Dare},\n  title = {dmeth: A comprehensive Python toolkit for differential DNA methylation analysis with empirical Bayes moderation and biomarker discovery},\n  version = {0.1.1},\n  year = {2025},\n  publisher = {GitHub},\n  url = {https://github.com/dare-afolabi/dmeth},\n  doi = {10.5281/zenodo.17684037},\n}\n</code></pre>"},{"location":"UserGuide/#references","title":"References","text":"<ul> <li>Smyth, G. K. (2004). Linear models and empirical bayes methods for assessing differential expression in microarray experiments. Statistical Applications in Genetics and Molecular Biology, 3(1).</li> <li>Liu, P., &amp; Hwang, J.T.G. (2007). Quick calculation for sample size while controlling false discovery rate with application to microarray analysis. Bioinformatics, 23(6), 739\u2013746.</li> <li>Du, P., Zhang, X., Huang, C.-C., Jafari, N., Kibbe, W.A., Hou, L., &amp; Lin, S. (2010). Comparison of Beta-value and M-value methods for quantifying methylation levels by microarray analysis. BMC Bioinformatics, 11:587.</li> <li>Jung, S.H., Young, S.S. (2012). Power and sample size calculation for microarray studies. Journal of Biopharmaceutical Statistics, 22(1):30-42.</li> <li>Phipson, B. et al. (2016). missMethyl: an R package for analyzing data from Illumina\u2019s HumanMethylation450 platform. Bioinformatics, 32(2), 286-288.</li> </ul>"},{"location":"UserGuide/#support","title":"Support","text":"<ul> <li>Issues: GitHub Issues</li> <li>Discussions: GitHub Discussions</li> <li>Email: dare.afolabi@outlook.com</li> </ul> <p>Auto-generated on 2025-11-22 21:20:22</p>"}]}